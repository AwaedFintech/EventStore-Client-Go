// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: streams.proto

package event_store_client_streams

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReadReq_Options_ReadDirection int32

const (
	ReadReq_Options_Forwards  ReadReq_Options_ReadDirection = 0
	ReadReq_Options_Backwards ReadReq_Options_ReadDirection = 1
)

var ReadReq_Options_ReadDirection_name = map[int32]string{
	0: "Forwards",
	1: "Backwards",
}

var ReadReq_Options_ReadDirection_value = map[string]int32{
	"Forwards":  0,
	"Backwards": 1,
}

func (x ReadReq_Options_ReadDirection) String() string {
	return proto.EnumName(ReadReq_Options_ReadDirection_name, int32(x))
}

func (ReadReq_Options_ReadDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 0}
}

type ReadReq struct {
	Options              *ReadReq_Options `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ReadReq) Reset()         { *m = ReadReq{} }
func (m *ReadReq) String() string { return proto.CompactTextString(m) }
func (*ReadReq) ProtoMessage()    {}
func (*ReadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0}
}
func (m *ReadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq.Merge(m, src)
}
func (m *ReadReq) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq proto.InternalMessageInfo

func (m *ReadReq) GetOptions() *ReadReq_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

type ReadReq_Options struct {
	// Types that are valid to be assigned to StreamOption:
	//	*ReadReq_Options_Stream
	//	*ReadReq_Options_All
	StreamOption  isReadReq_Options_StreamOption `protobuf_oneof:"stream_option"`
	ReadDirection ReadReq_Options_ReadDirection  `protobuf:"varint,3,opt,name=read_direction,json=readDirection,proto3,enum=event_store.client.streams.ReadReq_Options_ReadDirection" json:"read_direction,omitempty"`
	ResolveLinks  bool                           `protobuf:"varint,4,opt,name=resolve_links,json=resolveLinks,proto3" json:"resolve_links,omitempty"`
	// Types that are valid to be assigned to CountOption:
	//	*ReadReq_Options_Count
	//	*ReadReq_Options_Subscription
	CountOption isReadReq_Options_CountOption `protobuf_oneof:"count_option"`
	// Types that are valid to be assigned to FilterOption:
	//	*ReadReq_Options_Filter
	//	*ReadReq_Options_NoFilter
	FilterOption         isReadReq_Options_FilterOption `protobuf_oneof:"filter_option"`
	UuidOption           *ReadReq_Options_UUIDOption    `protobuf:"bytes,9,opt,name=uuid_option,json=uuidOption,proto3" json:"uuid_option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ReadReq_Options) Reset()         { *m = ReadReq_Options{} }
func (m *ReadReq_Options) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options) ProtoMessage()    {}
func (*ReadReq_Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0}
}
func (m *ReadReq_Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options.Merge(m, src)
}
func (m *ReadReq_Options) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options proto.InternalMessageInfo

type isReadReq_Options_StreamOption interface {
	isReadReq_Options_StreamOption()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReadReq_Options_CountOption interface {
	isReadReq_Options_CountOption()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReadReq_Options_FilterOption interface {
	isReadReq_Options_FilterOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadReq_Options_Stream struct {
	Stream *ReadReq_Options_StreamOptions `protobuf:"bytes,1,opt,name=stream,proto3,oneof" json:"stream,omitempty"`
}
type ReadReq_Options_All struct {
	All *ReadReq_Options_AllOptions `protobuf:"bytes,2,opt,name=all,proto3,oneof" json:"all,omitempty"`
}
type ReadReq_Options_Count struct {
	Count uint64 `protobuf:"varint,5,opt,name=count,proto3,oneof" json:"count,omitempty"`
}
type ReadReq_Options_Subscription struct {
	Subscription *ReadReq_Options_SubscriptionOptions `protobuf:"bytes,6,opt,name=subscription,proto3,oneof" json:"subscription,omitempty"`
}
type ReadReq_Options_Filter struct {
	Filter *ReadReq_Options_FilterOptions `protobuf:"bytes,7,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}
type ReadReq_Options_NoFilter struct {
	NoFilter *ReadReq_Empty `protobuf:"bytes,8,opt,name=no_filter,json=noFilter,proto3,oneof" json:"no_filter,omitempty"`
}

func (*ReadReq_Options_Stream) isReadReq_Options_StreamOption()      {}
func (*ReadReq_Options_All) isReadReq_Options_StreamOption()         {}
func (*ReadReq_Options_Count) isReadReq_Options_CountOption()        {}
func (*ReadReq_Options_Subscription) isReadReq_Options_CountOption() {}
func (*ReadReq_Options_Filter) isReadReq_Options_FilterOption()      {}
func (*ReadReq_Options_NoFilter) isReadReq_Options_FilterOption()    {}

func (m *ReadReq_Options) GetStreamOption() isReadReq_Options_StreamOption {
	if m != nil {
		return m.StreamOption
	}
	return nil
}
func (m *ReadReq_Options) GetCountOption() isReadReq_Options_CountOption {
	if m != nil {
		return m.CountOption
	}
	return nil
}
func (m *ReadReq_Options) GetFilterOption() isReadReq_Options_FilterOption {
	if m != nil {
		return m.FilterOption
	}
	return nil
}

func (m *ReadReq_Options) GetStream() *ReadReq_Options_StreamOptions {
	if x, ok := m.GetStreamOption().(*ReadReq_Options_Stream); ok {
		return x.Stream
	}
	return nil
}

func (m *ReadReq_Options) GetAll() *ReadReq_Options_AllOptions {
	if x, ok := m.GetStreamOption().(*ReadReq_Options_All); ok {
		return x.All
	}
	return nil
}

func (m *ReadReq_Options) GetReadDirection() ReadReq_Options_ReadDirection {
	if m != nil {
		return m.ReadDirection
	}
	return ReadReq_Options_Forwards
}

func (m *ReadReq_Options) GetResolveLinks() bool {
	if m != nil {
		return m.ResolveLinks
	}
	return false
}

func (m *ReadReq_Options) GetCount() uint64 {
	if x, ok := m.GetCountOption().(*ReadReq_Options_Count); ok {
		return x.Count
	}
	return 0
}

func (m *ReadReq_Options) GetSubscription() *ReadReq_Options_SubscriptionOptions {
	if x, ok := m.GetCountOption().(*ReadReq_Options_Subscription); ok {
		return x.Subscription
	}
	return nil
}

func (m *ReadReq_Options) GetFilter() *ReadReq_Options_FilterOptions {
	if x, ok := m.GetFilterOption().(*ReadReq_Options_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *ReadReq_Options) GetNoFilter() *ReadReq_Empty {
	if x, ok := m.GetFilterOption().(*ReadReq_Options_NoFilter); ok {
		return x.NoFilter
	}
	return nil
}

func (m *ReadReq_Options) GetUuidOption() *ReadReq_Options_UUIDOption {
	if m != nil {
		return m.UuidOption
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadReq_Options) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadReq_Options_Stream)(nil),
		(*ReadReq_Options_All)(nil),
		(*ReadReq_Options_Count)(nil),
		(*ReadReq_Options_Subscription)(nil),
		(*ReadReq_Options_Filter)(nil),
		(*ReadReq_Options_NoFilter)(nil),
	}
}

type ReadReq_Options_StreamOptions struct {
	StreamName string `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Types that are valid to be assigned to RevisionOption:
	//	*ReadReq_Options_StreamOptions_Revision
	//	*ReadReq_Options_StreamOptions_Start
	//	*ReadReq_Options_StreamOptions_End
	RevisionOption       isReadReq_Options_StreamOptions_RevisionOption `protobuf_oneof:"revision_option"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *ReadReq_Options_StreamOptions) Reset()         { *m = ReadReq_Options_StreamOptions{} }
func (m *ReadReq_Options_StreamOptions) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_StreamOptions) ProtoMessage()    {}
func (*ReadReq_Options_StreamOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 0}
}
func (m *ReadReq_Options_StreamOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_StreamOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_StreamOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_StreamOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_StreamOptions.Merge(m, src)
}
func (m *ReadReq_Options_StreamOptions) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_StreamOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_StreamOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_StreamOptions proto.InternalMessageInfo

type isReadReq_Options_StreamOptions_RevisionOption interface {
	isReadReq_Options_StreamOptions_RevisionOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadReq_Options_StreamOptions_Revision struct {
	Revision uint64 `protobuf:"varint,2,opt,name=revision,proto3,oneof" json:"revision,omitempty"`
}
type ReadReq_Options_StreamOptions_Start struct {
	Start *ReadReq_Empty `protobuf:"bytes,3,opt,name=start,proto3,oneof" json:"start,omitempty"`
}
type ReadReq_Options_StreamOptions_End struct {
	End *ReadReq_Empty `protobuf:"bytes,4,opt,name=end,proto3,oneof" json:"end,omitempty"`
}

func (*ReadReq_Options_StreamOptions_Revision) isReadReq_Options_StreamOptions_RevisionOption() {}
func (*ReadReq_Options_StreamOptions_Start) isReadReq_Options_StreamOptions_RevisionOption()    {}
func (*ReadReq_Options_StreamOptions_End) isReadReq_Options_StreamOptions_RevisionOption()      {}

func (m *ReadReq_Options_StreamOptions) GetRevisionOption() isReadReq_Options_StreamOptions_RevisionOption {
	if m != nil {
		return m.RevisionOption
	}
	return nil
}

func (m *ReadReq_Options_StreamOptions) GetStreamName() string {
	if m != nil {
		return m.StreamName
	}
	return ""
}

func (m *ReadReq_Options_StreamOptions) GetRevision() uint64 {
	if x, ok := m.GetRevisionOption().(*ReadReq_Options_StreamOptions_Revision); ok {
		return x.Revision
	}
	return 0
}

func (m *ReadReq_Options_StreamOptions) GetStart() *ReadReq_Empty {
	if x, ok := m.GetRevisionOption().(*ReadReq_Options_StreamOptions_Start); ok {
		return x.Start
	}
	return nil
}

func (m *ReadReq_Options_StreamOptions) GetEnd() *ReadReq_Empty {
	if x, ok := m.GetRevisionOption().(*ReadReq_Options_StreamOptions_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadReq_Options_StreamOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadReq_Options_StreamOptions_Revision)(nil),
		(*ReadReq_Options_StreamOptions_Start)(nil),
		(*ReadReq_Options_StreamOptions_End)(nil),
	}
}

type ReadReq_Options_AllOptions struct {
	// Types that are valid to be assigned to AllOption:
	//	*ReadReq_Options_AllOptions_Position
	//	*ReadReq_Options_AllOptions_Start
	//	*ReadReq_Options_AllOptions_End
	AllOption            isReadReq_Options_AllOptions_AllOption `protobuf_oneof:"all_option"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *ReadReq_Options_AllOptions) Reset()         { *m = ReadReq_Options_AllOptions{} }
func (m *ReadReq_Options_AllOptions) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_AllOptions) ProtoMessage()    {}
func (*ReadReq_Options_AllOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 1}
}
func (m *ReadReq_Options_AllOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_AllOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_AllOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_AllOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_AllOptions.Merge(m, src)
}
func (m *ReadReq_Options_AllOptions) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_AllOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_AllOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_AllOptions proto.InternalMessageInfo

type isReadReq_Options_AllOptions_AllOption interface {
	isReadReq_Options_AllOptions_AllOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadReq_Options_AllOptions_Position struct {
	Position *ReadReq_Options_Position `protobuf:"bytes,1,opt,name=position,proto3,oneof" json:"position,omitempty"`
}
type ReadReq_Options_AllOptions_Start struct {
	Start *ReadReq_Empty `protobuf:"bytes,2,opt,name=start,proto3,oneof" json:"start,omitempty"`
}
type ReadReq_Options_AllOptions_End struct {
	End *ReadReq_Empty `protobuf:"bytes,3,opt,name=end,proto3,oneof" json:"end,omitempty"`
}

func (*ReadReq_Options_AllOptions_Position) isReadReq_Options_AllOptions_AllOption() {}
func (*ReadReq_Options_AllOptions_Start) isReadReq_Options_AllOptions_AllOption()    {}
func (*ReadReq_Options_AllOptions_End) isReadReq_Options_AllOptions_AllOption()      {}

func (m *ReadReq_Options_AllOptions) GetAllOption() isReadReq_Options_AllOptions_AllOption {
	if m != nil {
		return m.AllOption
	}
	return nil
}

func (m *ReadReq_Options_AllOptions) GetPosition() *ReadReq_Options_Position {
	if x, ok := m.GetAllOption().(*ReadReq_Options_AllOptions_Position); ok {
		return x.Position
	}
	return nil
}

func (m *ReadReq_Options_AllOptions) GetStart() *ReadReq_Empty {
	if x, ok := m.GetAllOption().(*ReadReq_Options_AllOptions_Start); ok {
		return x.Start
	}
	return nil
}

func (m *ReadReq_Options_AllOptions) GetEnd() *ReadReq_Empty {
	if x, ok := m.GetAllOption().(*ReadReq_Options_AllOptions_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadReq_Options_AllOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadReq_Options_AllOptions_Position)(nil),
		(*ReadReq_Options_AllOptions_Start)(nil),
		(*ReadReq_Options_AllOptions_End)(nil),
	}
}

type ReadReq_Options_SubscriptionOptions struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadReq_Options_SubscriptionOptions) Reset()         { *m = ReadReq_Options_SubscriptionOptions{} }
func (m *ReadReq_Options_SubscriptionOptions) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_SubscriptionOptions) ProtoMessage()    {}
func (*ReadReq_Options_SubscriptionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 2}
}
func (m *ReadReq_Options_SubscriptionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_SubscriptionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_SubscriptionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_SubscriptionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_SubscriptionOptions.Merge(m, src)
}
func (m *ReadReq_Options_SubscriptionOptions) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_SubscriptionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_SubscriptionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_SubscriptionOptions proto.InternalMessageInfo

type ReadReq_Options_Position struct {
	CommitPosition       uint64   `protobuf:"varint,1,opt,name=commit_position,json=commitPosition,proto3" json:"commit_position,omitempty"`
	PreparePosition      uint64   `protobuf:"varint,2,opt,name=prepare_position,json=preparePosition,proto3" json:"prepare_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadReq_Options_Position) Reset()         { *m = ReadReq_Options_Position{} }
func (m *ReadReq_Options_Position) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_Position) ProtoMessage()    {}
func (*ReadReq_Options_Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 3}
}
func (m *ReadReq_Options_Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_Position.Merge(m, src)
}
func (m *ReadReq_Options_Position) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_Position) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_Position.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_Position proto.InternalMessageInfo

func (m *ReadReq_Options_Position) GetCommitPosition() uint64 {
	if m != nil {
		return m.CommitPosition
	}
	return 0
}

func (m *ReadReq_Options_Position) GetPreparePosition() uint64 {
	if m != nil {
		return m.PreparePosition
	}
	return 0
}

type ReadReq_Options_FilterOptions struct {
	// Types that are valid to be assigned to Filter:
	//	*ReadReq_Options_FilterOptions_StreamName
	//	*ReadReq_Options_FilterOptions_EventType
	Filter isReadReq_Options_FilterOptions_Filter `protobuf_oneof:"filter"`
	// Types that are valid to be assigned to Window:
	//	*ReadReq_Options_FilterOptions_Max
	//	*ReadReq_Options_FilterOptions_Count
	Window               isReadReq_Options_FilterOptions_Window `protobuf_oneof:"window"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *ReadReq_Options_FilterOptions) Reset()         { *m = ReadReq_Options_FilterOptions{} }
func (m *ReadReq_Options_FilterOptions) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_FilterOptions) ProtoMessage()    {}
func (*ReadReq_Options_FilterOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 4}
}
func (m *ReadReq_Options_FilterOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_FilterOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_FilterOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_FilterOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_FilterOptions.Merge(m, src)
}
func (m *ReadReq_Options_FilterOptions) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_FilterOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_FilterOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_FilterOptions proto.InternalMessageInfo

type isReadReq_Options_FilterOptions_Filter interface {
	isReadReq_Options_FilterOptions_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReadReq_Options_FilterOptions_Window interface {
	isReadReq_Options_FilterOptions_Window()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadReq_Options_FilterOptions_StreamName struct {
	StreamName *ReadReq_Options_FilterOptions_Expression `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3,oneof" json:"stream_name,omitempty"`
}
type ReadReq_Options_FilterOptions_EventType struct {
	EventType *ReadReq_Options_FilterOptions_Expression `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3,oneof" json:"event_type,omitempty"`
}
type ReadReq_Options_FilterOptions_Max struct {
	Max int32 `protobuf:"varint,3,opt,name=max,proto3,oneof" json:"max,omitempty"`
}
type ReadReq_Options_FilterOptions_Count struct {
	Count *ReadReq_Empty `protobuf:"bytes,4,opt,name=count,proto3,oneof" json:"count,omitempty"`
}

func (*ReadReq_Options_FilterOptions_StreamName) isReadReq_Options_FilterOptions_Filter() {}
func (*ReadReq_Options_FilterOptions_EventType) isReadReq_Options_FilterOptions_Filter()  {}
func (*ReadReq_Options_FilterOptions_Max) isReadReq_Options_FilterOptions_Window()        {}
func (*ReadReq_Options_FilterOptions_Count) isReadReq_Options_FilterOptions_Window()      {}

func (m *ReadReq_Options_FilterOptions) GetFilter() isReadReq_Options_FilterOptions_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}
func (m *ReadReq_Options_FilterOptions) GetWindow() isReadReq_Options_FilterOptions_Window {
	if m != nil {
		return m.Window
	}
	return nil
}

func (m *ReadReq_Options_FilterOptions) GetStreamName() *ReadReq_Options_FilterOptions_Expression {
	if x, ok := m.GetFilter().(*ReadReq_Options_FilterOptions_StreamName); ok {
		return x.StreamName
	}
	return nil
}

func (m *ReadReq_Options_FilterOptions) GetEventType() *ReadReq_Options_FilterOptions_Expression {
	if x, ok := m.GetFilter().(*ReadReq_Options_FilterOptions_EventType); ok {
		return x.EventType
	}
	return nil
}

func (m *ReadReq_Options_FilterOptions) GetMax() int32 {
	if x, ok := m.GetWindow().(*ReadReq_Options_FilterOptions_Max); ok {
		return x.Max
	}
	return 0
}

func (m *ReadReq_Options_FilterOptions) GetCount() *ReadReq_Empty {
	if x, ok := m.GetWindow().(*ReadReq_Options_FilterOptions_Count); ok {
		return x.Count
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadReq_Options_FilterOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadReq_Options_FilterOptions_StreamName)(nil),
		(*ReadReq_Options_FilterOptions_EventType)(nil),
		(*ReadReq_Options_FilterOptions_Max)(nil),
		(*ReadReq_Options_FilterOptions_Count)(nil),
	}
}

type ReadReq_Options_FilterOptions_Expression struct {
	Regex                string   `protobuf:"bytes,1,opt,name=regex,proto3" json:"regex,omitempty"`
	Prefix               []string `protobuf:"bytes,2,rep,name=prefix,proto3" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadReq_Options_FilterOptions_Expression) Reset() {
	*m = ReadReq_Options_FilterOptions_Expression{}
}
func (m *ReadReq_Options_FilterOptions_Expression) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_FilterOptions_Expression) ProtoMessage()    {}
func (*ReadReq_Options_FilterOptions_Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 4, 0}
}
func (m *ReadReq_Options_FilterOptions_Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_FilterOptions_Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_FilterOptions_Expression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_FilterOptions_Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_FilterOptions_Expression.Merge(m, src)
}
func (m *ReadReq_Options_FilterOptions_Expression) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_FilterOptions_Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_FilterOptions_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_FilterOptions_Expression proto.InternalMessageInfo

func (m *ReadReq_Options_FilterOptions_Expression) GetRegex() string {
	if m != nil {
		return m.Regex
	}
	return ""
}

func (m *ReadReq_Options_FilterOptions_Expression) GetPrefix() []string {
	if m != nil {
		return m.Prefix
	}
	return nil
}

type ReadReq_Options_UUIDOption struct {
	// Types that are valid to be assigned to Content:
	//	*ReadReq_Options_UUIDOption_Structured
	//	*ReadReq_Options_UUIDOption_String_
	Content              isReadReq_Options_UUIDOption_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ReadReq_Options_UUIDOption) Reset()         { *m = ReadReq_Options_UUIDOption{} }
func (m *ReadReq_Options_UUIDOption) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Options_UUIDOption) ProtoMessage()    {}
func (*ReadReq_Options_UUIDOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 0, 5}
}
func (m *ReadReq_Options_UUIDOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Options_UUIDOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Options_UUIDOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Options_UUIDOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Options_UUIDOption.Merge(m, src)
}
func (m *ReadReq_Options_UUIDOption) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Options_UUIDOption) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Options_UUIDOption.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Options_UUIDOption proto.InternalMessageInfo

type isReadReq_Options_UUIDOption_Content interface {
	isReadReq_Options_UUIDOption_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadReq_Options_UUIDOption_Structured struct {
	Structured *ReadReq_Empty `protobuf:"bytes,1,opt,name=structured,proto3,oneof" json:"structured,omitempty"`
}
type ReadReq_Options_UUIDOption_String_ struct {
	String_ *ReadReq_Empty `protobuf:"bytes,2,opt,name=string,proto3,oneof" json:"string,omitempty"`
}

func (*ReadReq_Options_UUIDOption_Structured) isReadReq_Options_UUIDOption_Content() {}
func (*ReadReq_Options_UUIDOption_String_) isReadReq_Options_UUIDOption_Content()    {}

func (m *ReadReq_Options_UUIDOption) GetContent() isReadReq_Options_UUIDOption_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ReadReq_Options_UUIDOption) GetStructured() *ReadReq_Empty {
	if x, ok := m.GetContent().(*ReadReq_Options_UUIDOption_Structured); ok {
		return x.Structured
	}
	return nil
}

func (m *ReadReq_Options_UUIDOption) GetString_() *ReadReq_Empty {
	if x, ok := m.GetContent().(*ReadReq_Options_UUIDOption_String_); ok {
		return x.String_
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadReq_Options_UUIDOption) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadReq_Options_UUIDOption_Structured)(nil),
		(*ReadReq_Options_UUIDOption_String_)(nil),
	}
}

type ReadReq_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadReq_Empty) Reset()         { *m = ReadReq_Empty{} }
func (m *ReadReq_Empty) String() string { return proto.CompactTextString(m) }
func (*ReadReq_Empty) ProtoMessage()    {}
func (*ReadReq_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{0, 1}
}
func (m *ReadReq_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadReq_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadReq_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadReq_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadReq_Empty.Merge(m, src)
}
func (m *ReadReq_Empty) XXX_Size() int {
	return m.Size()
}
func (m *ReadReq_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadReq_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_ReadReq_Empty proto.InternalMessageInfo

type ReadResp struct {
	Event                *ReadResp_ReadEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ReadResp) Reset()         { *m = ReadResp{} }
func (m *ReadResp) String() string { return proto.CompactTextString(m) }
func (*ReadResp) ProtoMessage()    {}
func (*ReadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{1}
}
func (m *ReadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResp.Merge(m, src)
}
func (m *ReadResp) XXX_Size() int {
	return m.Size()
}
func (m *ReadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResp.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResp proto.InternalMessageInfo

func (m *ReadResp) GetEvent() *ReadResp_ReadEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

type ReadResp_ReadEvent struct {
	Event *ReadResp_ReadEvent_RecordedEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	Link  *ReadResp_ReadEvent_RecordedEvent `protobuf:"bytes,2,opt,name=link,proto3" json:"link,omitempty"`
	// Types that are valid to be assigned to Position:
	//	*ReadResp_ReadEvent_CommitPosition
	//	*ReadResp_ReadEvent_NoPosition
	Position             isReadResp_ReadEvent_Position `protobuf_oneof:"position"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ReadResp_ReadEvent) Reset()         { *m = ReadResp_ReadEvent{} }
func (m *ReadResp_ReadEvent) String() string { return proto.CompactTextString(m) }
func (*ReadResp_ReadEvent) ProtoMessage()    {}
func (*ReadResp_ReadEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{1, 0}
}
func (m *ReadResp_ReadEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResp_ReadEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResp_ReadEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResp_ReadEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResp_ReadEvent.Merge(m, src)
}
func (m *ReadResp_ReadEvent) XXX_Size() int {
	return m.Size()
}
func (m *ReadResp_ReadEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResp_ReadEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResp_ReadEvent proto.InternalMessageInfo

type isReadResp_ReadEvent_Position interface {
	isReadResp_ReadEvent_Position()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadResp_ReadEvent_CommitPosition struct {
	CommitPosition uint64 `protobuf:"varint,3,opt,name=commit_position,json=commitPosition,proto3,oneof" json:"commit_position,omitempty"`
}
type ReadResp_ReadEvent_NoPosition struct {
	NoPosition *ReadResp_Empty `protobuf:"bytes,4,opt,name=no_position,json=noPosition,proto3,oneof" json:"no_position,omitempty"`
}

func (*ReadResp_ReadEvent_CommitPosition) isReadResp_ReadEvent_Position() {}
func (*ReadResp_ReadEvent_NoPosition) isReadResp_ReadEvent_Position()     {}

func (m *ReadResp_ReadEvent) GetPosition() isReadResp_ReadEvent_Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *ReadResp_ReadEvent) GetEvent() *ReadResp_ReadEvent_RecordedEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *ReadResp_ReadEvent) GetLink() *ReadResp_ReadEvent_RecordedEvent {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *ReadResp_ReadEvent) GetCommitPosition() uint64 {
	if x, ok := m.GetPosition().(*ReadResp_ReadEvent_CommitPosition); ok {
		return x.CommitPosition
	}
	return 0
}

func (m *ReadResp_ReadEvent) GetNoPosition() *ReadResp_Empty {
	if x, ok := m.GetPosition().(*ReadResp_ReadEvent_NoPosition); ok {
		return x.NoPosition
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadResp_ReadEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadResp_ReadEvent_CommitPosition)(nil),
		(*ReadResp_ReadEvent_NoPosition)(nil),
	}
}

type ReadResp_ReadEvent_RecordedEvent struct {
	Id                   *UUID             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	StreamName           string            `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	StreamRevision       uint64            `protobuf:"varint,3,opt,name=stream_revision,json=streamRevision,proto3" json:"stream_revision,omitempty"`
	PreparePosition      uint64            `protobuf:"varint,4,opt,name=prepare_position,json=preparePosition,proto3" json:"prepare_position,omitempty"`
	CommitPosition       uint64            `protobuf:"varint,5,opt,name=commit_position,json=commitPosition,proto3" json:"commit_position,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CustomMetadata       []byte            `protobuf:"bytes,7,opt,name=custom_metadata,json=customMetadata,proto3" json:"custom_metadata,omitempty"`
	Data                 []byte            `protobuf:"bytes,8,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReadResp_ReadEvent_RecordedEvent) Reset()         { *m = ReadResp_ReadEvent_RecordedEvent{} }
func (m *ReadResp_ReadEvent_RecordedEvent) String() string { return proto.CompactTextString(m) }
func (*ReadResp_ReadEvent_RecordedEvent) ProtoMessage()    {}
func (*ReadResp_ReadEvent_RecordedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{1, 0, 0}
}
func (m *ReadResp_ReadEvent_RecordedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResp_ReadEvent_RecordedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResp_ReadEvent_RecordedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResp_ReadEvent_RecordedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResp_ReadEvent_RecordedEvent.Merge(m, src)
}
func (m *ReadResp_ReadEvent_RecordedEvent) XXX_Size() int {
	return m.Size()
}
func (m *ReadResp_ReadEvent_RecordedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResp_ReadEvent_RecordedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResp_ReadEvent_RecordedEvent proto.InternalMessageInfo

func (m *ReadResp_ReadEvent_RecordedEvent) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetStreamName() string {
	if m != nil {
		return m.StreamName
	}
	return ""
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetStreamRevision() uint64 {
	if m != nil {
		return m.StreamRevision
	}
	return 0
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetPreparePosition() uint64 {
	if m != nil {
		return m.PreparePosition
	}
	return 0
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetCommitPosition() uint64 {
	if m != nil {
		return m.CommitPosition
	}
	return 0
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetCustomMetadata() []byte {
	if m != nil {
		return m.CustomMetadata
	}
	return nil
}

func (m *ReadResp_ReadEvent_RecordedEvent) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ReadResp_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadResp_Empty) Reset()         { *m = ReadResp_Empty{} }
func (m *ReadResp_Empty) String() string { return proto.CompactTextString(m) }
func (*ReadResp_Empty) ProtoMessage()    {}
func (*ReadResp_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{1, 1}
}
func (m *ReadResp_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResp_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResp_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResp_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResp_Empty.Merge(m, src)
}
func (m *ReadResp_Empty) XXX_Size() int {
	return m.Size()
}
func (m *ReadResp_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResp_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResp_Empty proto.InternalMessageInfo

type AppendReq struct {
	// Types that are valid to be assigned to Content:
	//	*AppendReq_Options_
	//	*AppendReq_ProposedMessage_
	Content              isAppendReq_Content `protobuf_oneof:"content"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AppendReq) Reset()         { *m = AppendReq{} }
func (m *AppendReq) String() string { return proto.CompactTextString(m) }
func (*AppendReq) ProtoMessage()    {}
func (*AppendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{2}
}
func (m *AppendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReq.Merge(m, src)
}
func (m *AppendReq) XXX_Size() int {
	return m.Size()
}
func (m *AppendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReq.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReq proto.InternalMessageInfo

type isAppendReq_Content interface {
	isAppendReq_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppendReq_Options_ struct {
	Options *AppendReq_Options `protobuf:"bytes,1,opt,name=options,proto3,oneof" json:"options,omitempty"`
}
type AppendReq_ProposedMessage_ struct {
	ProposedMessage *AppendReq_ProposedMessage `protobuf:"bytes,2,opt,name=proposed_message,json=proposedMessage,proto3,oneof" json:"proposed_message,omitempty"`
}

func (*AppendReq_Options_) isAppendReq_Content()         {}
func (*AppendReq_ProposedMessage_) isAppendReq_Content() {}

func (m *AppendReq) GetContent() isAppendReq_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *AppendReq) GetOptions() *AppendReq_Options {
	if x, ok := m.GetContent().(*AppendReq_Options_); ok {
		return x.Options
	}
	return nil
}

func (m *AppendReq) GetProposedMessage() *AppendReq_ProposedMessage {
	if x, ok := m.GetContent().(*AppendReq_ProposedMessage_); ok {
		return x.ProposedMessage
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppendReq) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppendReq_Options_)(nil),
		(*AppendReq_ProposedMessage_)(nil),
	}
}

type AppendReq_Options struct {
	StreamName string `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Types that are valid to be assigned to ExpectedStreamRevision:
	//	*AppendReq_Options_Revision
	//	*AppendReq_Options_NoStream
	//	*AppendReq_Options_Any
	//	*AppendReq_Options_StreamExists
	ExpectedStreamRevision isAppendReq_Options_ExpectedStreamRevision `protobuf_oneof:"expected_stream_revision"`
	XXX_NoUnkeyedLiteral   struct{}                                   `json:"-"`
	XXX_unrecognized       []byte                                     `json:"-"`
	XXX_sizecache          int32                                      `json:"-"`
}

func (m *AppendReq_Options) Reset()         { *m = AppendReq_Options{} }
func (m *AppendReq_Options) String() string { return proto.CompactTextString(m) }
func (*AppendReq_Options) ProtoMessage()    {}
func (*AppendReq_Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{2, 0}
}
func (m *AppendReq_Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReq_Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReq_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendReq_Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReq_Options.Merge(m, src)
}
func (m *AppendReq_Options) XXX_Size() int {
	return m.Size()
}
func (m *AppendReq_Options) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReq_Options.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReq_Options proto.InternalMessageInfo

type isAppendReq_Options_ExpectedStreamRevision interface {
	isAppendReq_Options_ExpectedStreamRevision()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppendReq_Options_Revision struct {
	Revision uint64 `protobuf:"varint,2,opt,name=revision,proto3,oneof" json:"revision,omitempty"`
}
type AppendReq_Options_NoStream struct {
	NoStream *AppendReq_Empty `protobuf:"bytes,3,opt,name=no_stream,json=noStream,proto3,oneof" json:"no_stream,omitempty"`
}
type AppendReq_Options_Any struct {
	Any *AppendReq_Empty `protobuf:"bytes,4,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type AppendReq_Options_StreamExists struct {
	StreamExists *AppendReq_Empty `protobuf:"bytes,5,opt,name=stream_exists,json=streamExists,proto3,oneof" json:"stream_exists,omitempty"`
}

func (*AppendReq_Options_Revision) isAppendReq_Options_ExpectedStreamRevision()     {}
func (*AppendReq_Options_NoStream) isAppendReq_Options_ExpectedStreamRevision()     {}
func (*AppendReq_Options_Any) isAppendReq_Options_ExpectedStreamRevision()          {}
func (*AppendReq_Options_StreamExists) isAppendReq_Options_ExpectedStreamRevision() {}

func (m *AppendReq_Options) GetExpectedStreamRevision() isAppendReq_Options_ExpectedStreamRevision {
	if m != nil {
		return m.ExpectedStreamRevision
	}
	return nil
}

func (m *AppendReq_Options) GetStreamName() string {
	if m != nil {
		return m.StreamName
	}
	return ""
}

func (m *AppendReq_Options) GetRevision() uint64 {
	if x, ok := m.GetExpectedStreamRevision().(*AppendReq_Options_Revision); ok {
		return x.Revision
	}
	return 0
}

func (m *AppendReq_Options) GetNoStream() *AppendReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*AppendReq_Options_NoStream); ok {
		return x.NoStream
	}
	return nil
}

func (m *AppendReq_Options) GetAny() *AppendReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*AppendReq_Options_Any); ok {
		return x.Any
	}
	return nil
}

func (m *AppendReq_Options) GetStreamExists() *AppendReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*AppendReq_Options_StreamExists); ok {
		return x.StreamExists
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppendReq_Options) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppendReq_Options_Revision)(nil),
		(*AppendReq_Options_NoStream)(nil),
		(*AppendReq_Options_Any)(nil),
		(*AppendReq_Options_StreamExists)(nil),
	}
}

type AppendReq_ProposedMessage struct {
	Id                   *UUID             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,2,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CustomMetadata       []byte            `protobuf:"bytes,3,opt,name=custom_metadata,json=customMetadata,proto3" json:"custom_metadata,omitempty"`
	Data                 []byte            `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppendReq_ProposedMessage) Reset()         { *m = AppendReq_ProposedMessage{} }
func (m *AppendReq_ProposedMessage) String() string { return proto.CompactTextString(m) }
func (*AppendReq_ProposedMessage) ProtoMessage()    {}
func (*AppendReq_ProposedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{2, 1}
}
func (m *AppendReq_ProposedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReq_ProposedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReq_ProposedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendReq_ProposedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReq_ProposedMessage.Merge(m, src)
}
func (m *AppendReq_ProposedMessage) XXX_Size() int {
	return m.Size()
}
func (m *AppendReq_ProposedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReq_ProposedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReq_ProposedMessage proto.InternalMessageInfo

func (m *AppendReq_ProposedMessage) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AppendReq_ProposedMessage) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *AppendReq_ProposedMessage) GetCustomMetadata() []byte {
	if m != nil {
		return m.CustomMetadata
	}
	return nil
}

func (m *AppendReq_ProposedMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppendReq_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppendReq_Empty) Reset()         { *m = AppendReq_Empty{} }
func (m *AppendReq_Empty) String() string { return proto.CompactTextString(m) }
func (*AppendReq_Empty) ProtoMessage()    {}
func (*AppendReq_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{2, 2}
}
func (m *AppendReq_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReq_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReq_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendReq_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReq_Empty.Merge(m, src)
}
func (m *AppendReq_Empty) XXX_Size() int {
	return m.Size()
}
func (m *AppendReq_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReq_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReq_Empty proto.InternalMessageInfo

type AppendResp struct {
	// Types that are valid to be assigned to CurrentRevisionOption:
	//	*AppendResp_CurrentRevision
	//	*AppendResp_NoStream
	CurrentRevisionOption isAppendResp_CurrentRevisionOption `protobuf_oneof:"current_revision_option"`
	// Types that are valid to be assigned to PositionOption:
	//	*AppendResp_Position_
	//	*AppendResp_Empty_
	PositionOption       isAppendResp_PositionOption `protobuf_oneof:"position_option"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *AppendResp) Reset()         { *m = AppendResp{} }
func (m *AppendResp) String() string { return proto.CompactTextString(m) }
func (*AppendResp) ProtoMessage()    {}
func (*AppendResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{3}
}
func (m *AppendResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendResp.Merge(m, src)
}
func (m *AppendResp) XXX_Size() int {
	return m.Size()
}
func (m *AppendResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendResp.DiscardUnknown(m)
}

var xxx_messageInfo_AppendResp proto.InternalMessageInfo

type isAppendResp_CurrentRevisionOption interface {
	isAppendResp_CurrentRevisionOption()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAppendResp_PositionOption interface {
	isAppendResp_PositionOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppendResp_CurrentRevision struct {
	CurrentRevision uint64 `protobuf:"varint,1,opt,name=current_revision,json=currentRevision,proto3,oneof" json:"current_revision,omitempty"`
}
type AppendResp_NoStream struct {
	NoStream *AppendResp_Empty `protobuf:"bytes,2,opt,name=no_stream,json=noStream,proto3,oneof" json:"no_stream,omitempty"`
}
type AppendResp_Position_ struct {
	Position *AppendResp_Position `protobuf:"bytes,3,opt,name=position,proto3,oneof" json:"position,omitempty"`
}
type AppendResp_Empty_ struct {
	Empty *AppendResp_Empty `protobuf:"bytes,4,opt,name=empty,proto3,oneof" json:"empty,omitempty"`
}

func (*AppendResp_CurrentRevision) isAppendResp_CurrentRevisionOption() {}
func (*AppendResp_NoStream) isAppendResp_CurrentRevisionOption()        {}
func (*AppendResp_Position_) isAppendResp_PositionOption()              {}
func (*AppendResp_Empty_) isAppendResp_PositionOption()                 {}

func (m *AppendResp) GetCurrentRevisionOption() isAppendResp_CurrentRevisionOption {
	if m != nil {
		return m.CurrentRevisionOption
	}
	return nil
}
func (m *AppendResp) GetPositionOption() isAppendResp_PositionOption {
	if m != nil {
		return m.PositionOption
	}
	return nil
}

func (m *AppendResp) GetCurrentRevision() uint64 {
	if x, ok := m.GetCurrentRevisionOption().(*AppendResp_CurrentRevision); ok {
		return x.CurrentRevision
	}
	return 0
}

func (m *AppendResp) GetNoStream() *AppendResp_Empty {
	if x, ok := m.GetCurrentRevisionOption().(*AppendResp_NoStream); ok {
		return x.NoStream
	}
	return nil
}

func (m *AppendResp) GetPosition() *AppendResp_Position {
	if x, ok := m.GetPositionOption().(*AppendResp_Position_); ok {
		return x.Position
	}
	return nil
}

func (m *AppendResp) GetEmpty() *AppendResp_Empty {
	if x, ok := m.GetPositionOption().(*AppendResp_Empty_); ok {
		return x.Empty
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppendResp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppendResp_CurrentRevision)(nil),
		(*AppendResp_NoStream)(nil),
		(*AppendResp_Position_)(nil),
		(*AppendResp_Empty_)(nil),
	}
}

type AppendResp_Position struct {
	CommitPosition       uint64   `protobuf:"varint,1,opt,name=commit_position,json=commitPosition,proto3" json:"commit_position,omitempty"`
	PreparePosition      uint64   `protobuf:"varint,2,opt,name=prepare_position,json=preparePosition,proto3" json:"prepare_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppendResp_Position) Reset()         { *m = AppendResp_Position{} }
func (m *AppendResp_Position) String() string { return proto.CompactTextString(m) }
func (*AppendResp_Position) ProtoMessage()    {}
func (*AppendResp_Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{3, 0}
}
func (m *AppendResp_Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendResp_Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendResp_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendResp_Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendResp_Position.Merge(m, src)
}
func (m *AppendResp_Position) XXX_Size() int {
	return m.Size()
}
func (m *AppendResp_Position) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendResp_Position.DiscardUnknown(m)
}

var xxx_messageInfo_AppendResp_Position proto.InternalMessageInfo

func (m *AppendResp_Position) GetCommitPosition() uint64 {
	if m != nil {
		return m.CommitPosition
	}
	return 0
}

func (m *AppendResp_Position) GetPreparePosition() uint64 {
	if m != nil {
		return m.PreparePosition
	}
	return 0
}

type AppendResp_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppendResp_Empty) Reset()         { *m = AppendResp_Empty{} }
func (m *AppendResp_Empty) String() string { return proto.CompactTextString(m) }
func (*AppendResp_Empty) ProtoMessage()    {}
func (*AppendResp_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{3, 1}
}
func (m *AppendResp_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendResp_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendResp_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendResp_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendResp_Empty.Merge(m, src)
}
func (m *AppendResp_Empty) XXX_Size() int {
	return m.Size()
}
func (m *AppendResp_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendResp_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_AppendResp_Empty proto.InternalMessageInfo

type DeleteReq struct {
	Options              *DeleteReq_Options `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DeleteReq) Reset()         { *m = DeleteReq{} }
func (m *DeleteReq) String() string { return proto.CompactTextString(m) }
func (*DeleteReq) ProtoMessage()    {}
func (*DeleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{4}
}
func (m *DeleteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReq.Merge(m, src)
}
func (m *DeleteReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReq proto.InternalMessageInfo

func (m *DeleteReq) GetOptions() *DeleteReq_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

type DeleteReq_Options struct {
	StreamName string `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Types that are valid to be assigned to ExpectedStreamRevision:
	//	*DeleteReq_Options_Revision
	//	*DeleteReq_Options_NoStream
	//	*DeleteReq_Options_Any
	//	*DeleteReq_Options_StreamExists
	ExpectedStreamRevision isDeleteReq_Options_ExpectedStreamRevision `protobuf_oneof:"expected_stream_revision"`
	XXX_NoUnkeyedLiteral   struct{}                                   `json:"-"`
	XXX_unrecognized       []byte                                     `json:"-"`
	XXX_sizecache          int32                                      `json:"-"`
}

func (m *DeleteReq_Options) Reset()         { *m = DeleteReq_Options{} }
func (m *DeleteReq_Options) String() string { return proto.CompactTextString(m) }
func (*DeleteReq_Options) ProtoMessage()    {}
func (*DeleteReq_Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{4, 0}
}
func (m *DeleteReq_Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReq_Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReq_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReq_Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReq_Options.Merge(m, src)
}
func (m *DeleteReq_Options) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReq_Options) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReq_Options.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReq_Options proto.InternalMessageInfo

type isDeleteReq_Options_ExpectedStreamRevision interface {
	isDeleteReq_Options_ExpectedStreamRevision()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeleteReq_Options_Revision struct {
	Revision uint64 `protobuf:"varint,2,opt,name=revision,proto3,oneof" json:"revision,omitempty"`
}
type DeleteReq_Options_NoStream struct {
	NoStream *DeleteReq_Empty `protobuf:"bytes,3,opt,name=no_stream,json=noStream,proto3,oneof" json:"no_stream,omitempty"`
}
type DeleteReq_Options_Any struct {
	Any *DeleteReq_Empty `protobuf:"bytes,4,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type DeleteReq_Options_StreamExists struct {
	StreamExists *DeleteReq_Empty `protobuf:"bytes,5,opt,name=stream_exists,json=streamExists,proto3,oneof" json:"stream_exists,omitempty"`
}

func (*DeleteReq_Options_Revision) isDeleteReq_Options_ExpectedStreamRevision()     {}
func (*DeleteReq_Options_NoStream) isDeleteReq_Options_ExpectedStreamRevision()     {}
func (*DeleteReq_Options_Any) isDeleteReq_Options_ExpectedStreamRevision()          {}
func (*DeleteReq_Options_StreamExists) isDeleteReq_Options_ExpectedStreamRevision() {}

func (m *DeleteReq_Options) GetExpectedStreamRevision() isDeleteReq_Options_ExpectedStreamRevision {
	if m != nil {
		return m.ExpectedStreamRevision
	}
	return nil
}

func (m *DeleteReq_Options) GetStreamName() string {
	if m != nil {
		return m.StreamName
	}
	return ""
}

func (m *DeleteReq_Options) GetRevision() uint64 {
	if x, ok := m.GetExpectedStreamRevision().(*DeleteReq_Options_Revision); ok {
		return x.Revision
	}
	return 0
}

func (m *DeleteReq_Options) GetNoStream() *DeleteReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*DeleteReq_Options_NoStream); ok {
		return x.NoStream
	}
	return nil
}

func (m *DeleteReq_Options) GetAny() *DeleteReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*DeleteReq_Options_Any); ok {
		return x.Any
	}
	return nil
}

func (m *DeleteReq_Options) GetStreamExists() *DeleteReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*DeleteReq_Options_StreamExists); ok {
		return x.StreamExists
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeleteReq_Options) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeleteReq_Options_Revision)(nil),
		(*DeleteReq_Options_NoStream)(nil),
		(*DeleteReq_Options_Any)(nil),
		(*DeleteReq_Options_StreamExists)(nil),
	}
}

type DeleteReq_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteReq_Empty) Reset()         { *m = DeleteReq_Empty{} }
func (m *DeleteReq_Empty) String() string { return proto.CompactTextString(m) }
func (*DeleteReq_Empty) ProtoMessage()    {}
func (*DeleteReq_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{4, 1}
}
func (m *DeleteReq_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReq_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReq_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReq_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReq_Empty.Merge(m, src)
}
func (m *DeleteReq_Empty) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReq_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReq_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReq_Empty proto.InternalMessageInfo

type DeleteResp struct {
	// Types that are valid to be assigned to PositionOption:
	//	*DeleteResp_Position_
	//	*DeleteResp_Empty_
	PositionOption       isDeleteResp_PositionOption `protobuf_oneof:"position_option"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DeleteResp) Reset()         { *m = DeleteResp{} }
func (m *DeleteResp) String() string { return proto.CompactTextString(m) }
func (*DeleteResp) ProtoMessage()    {}
func (*DeleteResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{5}
}
func (m *DeleteResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResp.Merge(m, src)
}
func (m *DeleteResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResp proto.InternalMessageInfo

type isDeleteResp_PositionOption interface {
	isDeleteResp_PositionOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeleteResp_Position_ struct {
	Position *DeleteResp_Position `protobuf:"bytes,1,opt,name=position,proto3,oneof" json:"position,omitempty"`
}
type DeleteResp_Empty_ struct {
	Empty *DeleteResp_Empty `protobuf:"bytes,2,opt,name=empty,proto3,oneof" json:"empty,omitempty"`
}

func (*DeleteResp_Position_) isDeleteResp_PositionOption() {}
func (*DeleteResp_Empty_) isDeleteResp_PositionOption()    {}

func (m *DeleteResp) GetPositionOption() isDeleteResp_PositionOption {
	if m != nil {
		return m.PositionOption
	}
	return nil
}

func (m *DeleteResp) GetPosition() *DeleteResp_Position {
	if x, ok := m.GetPositionOption().(*DeleteResp_Position_); ok {
		return x.Position
	}
	return nil
}

func (m *DeleteResp) GetEmpty() *DeleteResp_Empty {
	if x, ok := m.GetPositionOption().(*DeleteResp_Empty_); ok {
		return x.Empty
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeleteResp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeleteResp_Position_)(nil),
		(*DeleteResp_Empty_)(nil),
	}
}

type DeleteResp_Position struct {
	CommitPosition       uint64   `protobuf:"varint,1,opt,name=commit_position,json=commitPosition,proto3" json:"commit_position,omitempty"`
	PreparePosition      uint64   `protobuf:"varint,2,opt,name=prepare_position,json=preparePosition,proto3" json:"prepare_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteResp_Position) Reset()         { *m = DeleteResp_Position{} }
func (m *DeleteResp_Position) String() string { return proto.CompactTextString(m) }
func (*DeleteResp_Position) ProtoMessage()    {}
func (*DeleteResp_Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{5, 0}
}
func (m *DeleteResp_Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResp_Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResp_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResp_Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResp_Position.Merge(m, src)
}
func (m *DeleteResp_Position) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResp_Position) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResp_Position.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResp_Position proto.InternalMessageInfo

func (m *DeleteResp_Position) GetCommitPosition() uint64 {
	if m != nil {
		return m.CommitPosition
	}
	return 0
}

func (m *DeleteResp_Position) GetPreparePosition() uint64 {
	if m != nil {
		return m.PreparePosition
	}
	return 0
}

type DeleteResp_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteResp_Empty) Reset()         { *m = DeleteResp_Empty{} }
func (m *DeleteResp_Empty) String() string { return proto.CompactTextString(m) }
func (*DeleteResp_Empty) ProtoMessage()    {}
func (*DeleteResp_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{5, 1}
}
func (m *DeleteResp_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResp_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResp_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResp_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResp_Empty.Merge(m, src)
}
func (m *DeleteResp_Empty) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResp_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResp_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResp_Empty proto.InternalMessageInfo

type TombstoneReq struct {
	Options              *TombstoneReq_Options `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TombstoneReq) Reset()         { *m = TombstoneReq{} }
func (m *TombstoneReq) String() string { return proto.CompactTextString(m) }
func (*TombstoneReq) ProtoMessage()    {}
func (*TombstoneReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{6}
}
func (m *TombstoneReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneReq.Merge(m, src)
}
func (m *TombstoneReq) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneReq.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneReq proto.InternalMessageInfo

func (m *TombstoneReq) GetOptions() *TombstoneReq_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

type TombstoneReq_Options struct {
	StreamName string `protobuf:"bytes,1,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
	// Types that are valid to be assigned to ExpectedStreamRevision:
	//	*TombstoneReq_Options_Revision
	//	*TombstoneReq_Options_NoStream
	//	*TombstoneReq_Options_Any
	//	*TombstoneReq_Options_StreamExists
	ExpectedStreamRevision isTombstoneReq_Options_ExpectedStreamRevision `protobuf_oneof:"expected_stream_revision"`
	XXX_NoUnkeyedLiteral   struct{}                                      `json:"-"`
	XXX_unrecognized       []byte                                        `json:"-"`
	XXX_sizecache          int32                                         `json:"-"`
}

func (m *TombstoneReq_Options) Reset()         { *m = TombstoneReq_Options{} }
func (m *TombstoneReq_Options) String() string { return proto.CompactTextString(m) }
func (*TombstoneReq_Options) ProtoMessage()    {}
func (*TombstoneReq_Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{6, 0}
}
func (m *TombstoneReq_Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneReq_Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneReq_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneReq_Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneReq_Options.Merge(m, src)
}
func (m *TombstoneReq_Options) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneReq_Options) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneReq_Options.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneReq_Options proto.InternalMessageInfo

type isTombstoneReq_Options_ExpectedStreamRevision interface {
	isTombstoneReq_Options_ExpectedStreamRevision()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TombstoneReq_Options_Revision struct {
	Revision uint64 `protobuf:"varint,2,opt,name=revision,proto3,oneof" json:"revision,omitempty"`
}
type TombstoneReq_Options_NoStream struct {
	NoStream *TombstoneReq_Empty `protobuf:"bytes,3,opt,name=no_stream,json=noStream,proto3,oneof" json:"no_stream,omitempty"`
}
type TombstoneReq_Options_Any struct {
	Any *TombstoneReq_Empty `protobuf:"bytes,4,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type TombstoneReq_Options_StreamExists struct {
	StreamExists *TombstoneReq_Empty `protobuf:"bytes,5,opt,name=stream_exists,json=streamExists,proto3,oneof" json:"stream_exists,omitempty"`
}

func (*TombstoneReq_Options_Revision) isTombstoneReq_Options_ExpectedStreamRevision()     {}
func (*TombstoneReq_Options_NoStream) isTombstoneReq_Options_ExpectedStreamRevision()     {}
func (*TombstoneReq_Options_Any) isTombstoneReq_Options_ExpectedStreamRevision()          {}
func (*TombstoneReq_Options_StreamExists) isTombstoneReq_Options_ExpectedStreamRevision() {}

func (m *TombstoneReq_Options) GetExpectedStreamRevision() isTombstoneReq_Options_ExpectedStreamRevision {
	if m != nil {
		return m.ExpectedStreamRevision
	}
	return nil
}

func (m *TombstoneReq_Options) GetStreamName() string {
	if m != nil {
		return m.StreamName
	}
	return ""
}

func (m *TombstoneReq_Options) GetRevision() uint64 {
	if x, ok := m.GetExpectedStreamRevision().(*TombstoneReq_Options_Revision); ok {
		return x.Revision
	}
	return 0
}

func (m *TombstoneReq_Options) GetNoStream() *TombstoneReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*TombstoneReq_Options_NoStream); ok {
		return x.NoStream
	}
	return nil
}

func (m *TombstoneReq_Options) GetAny() *TombstoneReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*TombstoneReq_Options_Any); ok {
		return x.Any
	}
	return nil
}

func (m *TombstoneReq_Options) GetStreamExists() *TombstoneReq_Empty {
	if x, ok := m.GetExpectedStreamRevision().(*TombstoneReq_Options_StreamExists); ok {
		return x.StreamExists
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TombstoneReq_Options) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TombstoneReq_Options_Revision)(nil),
		(*TombstoneReq_Options_NoStream)(nil),
		(*TombstoneReq_Options_Any)(nil),
		(*TombstoneReq_Options_StreamExists)(nil),
	}
}

type TombstoneReq_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TombstoneReq_Empty) Reset()         { *m = TombstoneReq_Empty{} }
func (m *TombstoneReq_Empty) String() string { return proto.CompactTextString(m) }
func (*TombstoneReq_Empty) ProtoMessage()    {}
func (*TombstoneReq_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{6, 1}
}
func (m *TombstoneReq_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneReq_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneReq_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneReq_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneReq_Empty.Merge(m, src)
}
func (m *TombstoneReq_Empty) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneReq_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneReq_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneReq_Empty proto.InternalMessageInfo

type TombstoneResp struct {
	// Types that are valid to be assigned to PositionOption:
	//	*TombstoneResp_Position_
	//	*TombstoneResp_Empty_
	PositionOption       isTombstoneResp_PositionOption `protobuf_oneof:"position_option"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TombstoneResp) Reset()         { *m = TombstoneResp{} }
func (m *TombstoneResp) String() string { return proto.CompactTextString(m) }
func (*TombstoneResp) ProtoMessage()    {}
func (*TombstoneResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{7}
}
func (m *TombstoneResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneResp.Merge(m, src)
}
func (m *TombstoneResp) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneResp.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneResp proto.InternalMessageInfo

type isTombstoneResp_PositionOption interface {
	isTombstoneResp_PositionOption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TombstoneResp_Position_ struct {
	Position *TombstoneResp_Position `protobuf:"bytes,1,opt,name=position,proto3,oneof" json:"position,omitempty"`
}
type TombstoneResp_Empty_ struct {
	Empty *TombstoneResp_Empty `protobuf:"bytes,2,opt,name=empty,proto3,oneof" json:"empty,omitempty"`
}

func (*TombstoneResp_Position_) isTombstoneResp_PositionOption() {}
func (*TombstoneResp_Empty_) isTombstoneResp_PositionOption()    {}

func (m *TombstoneResp) GetPositionOption() isTombstoneResp_PositionOption {
	if m != nil {
		return m.PositionOption
	}
	return nil
}

func (m *TombstoneResp) GetPosition() *TombstoneResp_Position {
	if x, ok := m.GetPositionOption().(*TombstoneResp_Position_); ok {
		return x.Position
	}
	return nil
}

func (m *TombstoneResp) GetEmpty() *TombstoneResp_Empty {
	if x, ok := m.GetPositionOption().(*TombstoneResp_Empty_); ok {
		return x.Empty
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TombstoneResp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TombstoneResp_Position_)(nil),
		(*TombstoneResp_Empty_)(nil),
	}
}

type TombstoneResp_Position struct {
	CommitPosition       uint64   `protobuf:"varint,1,opt,name=commit_position,json=commitPosition,proto3" json:"commit_position,omitempty"`
	PreparePosition      uint64   `protobuf:"varint,2,opt,name=prepare_position,json=preparePosition,proto3" json:"prepare_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TombstoneResp_Position) Reset()         { *m = TombstoneResp_Position{} }
func (m *TombstoneResp_Position) String() string { return proto.CompactTextString(m) }
func (*TombstoneResp_Position) ProtoMessage()    {}
func (*TombstoneResp_Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{7, 0}
}
func (m *TombstoneResp_Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneResp_Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneResp_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneResp_Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneResp_Position.Merge(m, src)
}
func (m *TombstoneResp_Position) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneResp_Position) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneResp_Position.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneResp_Position proto.InternalMessageInfo

func (m *TombstoneResp_Position) GetCommitPosition() uint64 {
	if m != nil {
		return m.CommitPosition
	}
	return 0
}

func (m *TombstoneResp_Position) GetPreparePosition() uint64 {
	if m != nil {
		return m.PreparePosition
	}
	return 0
}

type TombstoneResp_Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TombstoneResp_Empty) Reset()         { *m = TombstoneResp_Empty{} }
func (m *TombstoneResp_Empty) String() string { return proto.CompactTextString(m) }
func (*TombstoneResp_Empty) ProtoMessage()    {}
func (*TombstoneResp_Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{7, 1}
}
func (m *TombstoneResp_Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TombstoneResp_Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TombstoneResp_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TombstoneResp_Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TombstoneResp_Empty.Merge(m, src)
}
func (m *TombstoneResp_Empty) XXX_Size() int {
	return m.Size()
}
func (m *TombstoneResp_Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_TombstoneResp_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_TombstoneResp_Empty proto.InternalMessageInfo

type UUID struct {
	// Types that are valid to be assigned to Value:
	//	*UUID_Structured_
	//	*UUID_String_
	Value                isUUID_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{8}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

type isUUID_Value interface {
	isUUID_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UUID_Structured_ struct {
	Structured *UUID_Structured `protobuf:"bytes,1,opt,name=structured,proto3,oneof" json:"structured,omitempty"`
}
type UUID_String_ struct {
	String_ string `protobuf:"bytes,2,opt,name=string,proto3,oneof" json:"string,omitempty"`
}

func (*UUID_Structured_) isUUID_Value() {}
func (*UUID_String_) isUUID_Value()     {}

func (m *UUID) GetValue() isUUID_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *UUID) GetStructured() *UUID_Structured {
	if x, ok := m.GetValue().(*UUID_Structured_); ok {
		return x.Structured
	}
	return nil
}

func (m *UUID) GetString_() string {
	if x, ok := m.GetValue().(*UUID_String_); ok {
		return x.String_
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UUID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UUID_Structured_)(nil),
		(*UUID_String_)(nil),
	}
}

type UUID_Structured struct {
	MostSignificantBits  int64    `protobuf:"varint,1,opt,name=most_significant_bits,json=mostSignificantBits,proto3" json:"most_significant_bits,omitempty"`
	LeastSignificantBits int64    `protobuf:"varint,2,opt,name=least_significant_bits,json=leastSignificantBits,proto3" json:"least_significant_bits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UUID_Structured) Reset()         { *m = UUID_Structured{} }
func (m *UUID_Structured) String() string { return proto.CompactTextString(m) }
func (*UUID_Structured) ProtoMessage()    {}
func (*UUID_Structured) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6bbf8af0ec331d6, []int{8, 0}
}
func (m *UUID_Structured) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID_Structured) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID_Structured.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID_Structured) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID_Structured.Merge(m, src)
}
func (m *UUID_Structured) XXX_Size() int {
	return m.Size()
}
func (m *UUID_Structured) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID_Structured.DiscardUnknown(m)
}

var xxx_messageInfo_UUID_Structured proto.InternalMessageInfo

func (m *UUID_Structured) GetMostSignificantBits() int64 {
	if m != nil {
		return m.MostSignificantBits
	}
	return 0
}

func (m *UUID_Structured) GetLeastSignificantBits() int64 {
	if m != nil {
		return m.LeastSignificantBits
	}
	return 0
}

func init() {
	proto.RegisterEnum("event_store.client.streams.ReadReq_Options_ReadDirection", ReadReq_Options_ReadDirection_name, ReadReq_Options_ReadDirection_value)
	proto.RegisterType((*ReadReq)(nil), "event_store.client.streams.ReadReq")
	proto.RegisterType((*ReadReq_Options)(nil), "event_store.client.streams.ReadReq.Options")
	proto.RegisterType((*ReadReq_Options_StreamOptions)(nil), "event_store.client.streams.ReadReq.Options.StreamOptions")
	proto.RegisterType((*ReadReq_Options_AllOptions)(nil), "event_store.client.streams.ReadReq.Options.AllOptions")
	proto.RegisterType((*ReadReq_Options_SubscriptionOptions)(nil), "event_store.client.streams.ReadReq.Options.SubscriptionOptions")
	proto.RegisterType((*ReadReq_Options_Position)(nil), "event_store.client.streams.ReadReq.Options.Position")
	proto.RegisterType((*ReadReq_Options_FilterOptions)(nil), "event_store.client.streams.ReadReq.Options.FilterOptions")
	proto.RegisterType((*ReadReq_Options_FilterOptions_Expression)(nil), "event_store.client.streams.ReadReq.Options.FilterOptions.Expression")
	proto.RegisterType((*ReadReq_Options_UUIDOption)(nil), "event_store.client.streams.ReadReq.Options.UUIDOption")
	proto.RegisterType((*ReadReq_Empty)(nil), "event_store.client.streams.ReadReq.Empty")
	proto.RegisterType((*ReadResp)(nil), "event_store.client.streams.ReadResp")
	proto.RegisterType((*ReadResp_ReadEvent)(nil), "event_store.client.streams.ReadResp.ReadEvent")
	proto.RegisterType((*ReadResp_ReadEvent_RecordedEvent)(nil), "event_store.client.streams.ReadResp.ReadEvent.RecordedEvent")
	proto.RegisterMapType((map[string]string)(nil), "event_store.client.streams.ReadResp.ReadEvent.RecordedEvent.MetadataEntry")
	proto.RegisterType((*ReadResp_Empty)(nil), "event_store.client.streams.ReadResp.Empty")
	proto.RegisterType((*AppendReq)(nil), "event_store.client.streams.AppendReq")
	proto.RegisterType((*AppendReq_Options)(nil), "event_store.client.streams.AppendReq.Options")
	proto.RegisterType((*AppendReq_ProposedMessage)(nil), "event_store.client.streams.AppendReq.ProposedMessage")
	proto.RegisterMapType((map[string]string)(nil), "event_store.client.streams.AppendReq.ProposedMessage.MetadataEntry")
	proto.RegisterType((*AppendReq_Empty)(nil), "event_store.client.streams.AppendReq.Empty")
	proto.RegisterType((*AppendResp)(nil), "event_store.client.streams.AppendResp")
	proto.RegisterType((*AppendResp_Position)(nil), "event_store.client.streams.AppendResp.Position")
	proto.RegisterType((*AppendResp_Empty)(nil), "event_store.client.streams.AppendResp.Empty")
	proto.RegisterType((*DeleteReq)(nil), "event_store.client.streams.DeleteReq")
	proto.RegisterType((*DeleteReq_Options)(nil), "event_store.client.streams.DeleteReq.Options")
	proto.RegisterType((*DeleteReq_Empty)(nil), "event_store.client.streams.DeleteReq.Empty")
	proto.RegisterType((*DeleteResp)(nil), "event_store.client.streams.DeleteResp")
	proto.RegisterType((*DeleteResp_Position)(nil), "event_store.client.streams.DeleteResp.Position")
	proto.RegisterType((*DeleteResp_Empty)(nil), "event_store.client.streams.DeleteResp.Empty")
	proto.RegisterType((*TombstoneReq)(nil), "event_store.client.streams.TombstoneReq")
	proto.RegisterType((*TombstoneReq_Options)(nil), "event_store.client.streams.TombstoneReq.Options")
	proto.RegisterType((*TombstoneReq_Empty)(nil), "event_store.client.streams.TombstoneReq.Empty")
	proto.RegisterType((*TombstoneResp)(nil), "event_store.client.streams.TombstoneResp")
	proto.RegisterType((*TombstoneResp_Position)(nil), "event_store.client.streams.TombstoneResp.Position")
	proto.RegisterType((*TombstoneResp_Empty)(nil), "event_store.client.streams.TombstoneResp.Empty")
	proto.RegisterType((*UUID)(nil), "event_store.client.streams.UUID")
	proto.RegisterType((*UUID_Structured)(nil), "event_store.client.streams.UUID.Structured")
}

func init() { proto.RegisterFile("streams.proto", fileDescriptor_c6bbf8af0ec331d6) }

var fileDescriptor_c6bbf8af0ec331d6 = []byte{
	// 1541 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xbb, 0x6f, 0x1c, 0x45,
	0x18, 0xf7, 0xee, 0xde, 0xf3, 0xf3, 0x9d, 0xcf, 0x99, 0x3c, 0x38, 0x56, 0x60, 0x4e, 0x0e, 0x90,
	0x33, 0x09, 0x9b, 0xc8, 0x04, 0x04, 0x01, 0x14, 0xe5, 0x62, 0x27, 0x8e, 0x83, 0xc1, 0x1a, 0x27,
	0x8a, 0x68, 0xb8, 0xac, 0xef, 0xc6, 0xd6, 0x2a, 0x77, 0xbb, 0xcb, 0xce, 0x9c, 0x63, 0xff, 0x03,
	0x74, 0xf4, 0x34, 0xd0, 0x81, 0x44, 0x8b, 0x90, 0xa8, 0x29, 0x90, 0xa8, 0x10, 0x1d, 0x2d, 0x4a,
	0x2a, 0xba, 0x14, 0x74, 0x34, 0x68, 0x1e, 0xfb, 0xb8, 0x47, 0xec, 0xdd, 0x73, 0x78, 0x74, 0x37,
	0x8f, 0xdf, 0x6f, 0x67, 0xbe, 0xef, 0xf7, 0x3d, 0xc6, 0x86, 0x2a, 0x65, 0x01, 0xb1, 0xfb, 0xd4,
	0xf2, 0x03, 0x8f, 0x79, 0xc8, 0x24, 0x7b, 0xc4, 0x65, 0x6d, 0xca, 0xbc, 0x80, 0x58, 0x9d, 0x9e,
	0x43, 0x5c, 0x66, 0xa9, 0x1d, 0x8b, 0x7f, 0xd4, 0xa0, 0x88, 0x89, 0xdd, 0xc5, 0xe4, 0x53, 0xb4,
	0x0a, 0x45, 0xcf, 0x67, 0x8e, 0xe7, 0xd2, 0xba, 0xd6, 0xd0, 0x9a, 0xb3, 0xcb, 0xe7, 0xad, 0xa7,
	0x23, 0x2d, 0x85, 0xb2, 0x3e, 0x92, 0x10, 0x1c, 0x62, 0xcd, 0xcf, 0x6b, 0x50, 0x54, 0x93, 0x68,
	0x0b, 0x0a, 0x72, 0xbf, 0x62, 0x7c, 0x27, 0x03, 0xa3, 0xb5, 0x25, 0xe6, 0xd5, 0x68, 0x6d, 0x06,
	0x2b, 0x2a, 0xb4, 0x0e, 0x86, 0xdd, 0xeb, 0xd5, 0x75, 0xc1, 0xf8, 0x56, 0x16, 0xc6, 0x6b, 0xbd,
	0x5e, 0x4c, 0xc7, 0x49, 0xd0, 0x7d, 0x98, 0x0b, 0x88, 0xdd, 0x6d, 0x77, 0x9d, 0x80, 0x74, 0xf8,
	0x4a, 0xdd, 0x68, 0x68, 0xcd, 0xb9, 0x6c, 0x07, 0xe5, 0xe3, 0x95, 0x90, 0x00, 0x57, 0x83, 0xe4,
	0x10, 0x9d, 0x85, 0x6a, 0x40, 0xa8, 0xd7, 0xdb, 0x23, 0xed, 0x9e, 0xe3, 0x3e, 0xa0, 0xf5, 0x5c,
	0x43, 0x6b, 0x96, 0x70, 0x45, 0x4d, 0x7e, 0xc0, 0xe7, 0xd0, 0x19, 0xc8, 0x77, 0xbc, 0x81, 0xcb,
	0xea, 0xf9, 0x86, 0xd6, 0xcc, 0xad, 0x69, 0x58, 0x0e, 0x11, 0x81, 0x0a, 0x1d, 0x6c, 0xd3, 0x4e,
	0xe0, 0x88, 0x4f, 0xd5, 0x0b, 0xe2, 0xce, 0x57, 0x33, 0x59, 0x31, 0x81, 0x0f, 0x2f, 0xaf, 0xe1,
	0x21, 0x5a, 0xee, 0xa6, 0x1d, 0xa7, 0xc7, 0x48, 0x50, 0x2f, 0x66, 0x77, 0xd3, 0x0d, 0x81, 0x0c,
	0xa9, 0x75, 0xac, 0xa8, 0xd0, 0x1a, 0x94, 0x5d, 0xaf, 0xad, 0x78, 0x4b, 0x82, 0x77, 0x29, 0x0d,
	0xef, 0x6a, 0xdf, 0x67, 0x07, 0x6b, 0x3a, 0x2e, 0xb9, 0x9e, 0xa4, 0x46, 0xf7, 0x60, 0x76, 0x30,
	0x70, 0xba, 0x6d, 0xa9, 0xb0, 0x7a, 0x39, 0xbb, 0xe3, 0xef, 0xde, 0xbd, 0xb5, 0x22, 0x7f, 0x63,
	0xe0, 0x54, 0xf2, 0xb7, 0xf9, 0x58, 0x83, 0xea, 0x90, 0xca, 0xd0, 0x4b, 0x30, 0x2b, 0x39, 0xda,
	0xae, 0xdd, 0x27, 0x42, 0xb5, 0x65, 0x0c, 0x72, 0xea, 0x43, 0xbb, 0x4f, 0xd0, 0x0b, 0x50, 0x0a,
	0xc8, 0x9e, 0x43, 0xf9, 0x41, 0x74, 0xe1, 0xac, 0x19, 0x1c, 0xcd, 0xa0, 0x6b, 0x90, 0xa7, 0xcc,
	0x0e, 0x98, 0x50, 0x51, 0xa6, 0xfb, 0xce, 0x60, 0x89, 0x44, 0xef, 0x83, 0x41, 0xdc, 0xae, 0x50,
	0x49, 0x46, 0x02, 0x8e, 0x6b, 0x9d, 0x80, 0x5a, 0x78, 0x1a, 0x65, 0x2f, 0xf3, 0x89, 0x06, 0x10,
	0x2b, 0x1f, 0x61, 0x28, 0xf9, 0x1e, 0x75, 0x84, 0x29, 0x65, 0x54, 0x5e, 0xce, 0x62, 0xca, 0x4d,
	0x85, 0xe5, 0xf7, 0x0e, 0x79, 0xe2, 0x7b, 0xeb, 0xc7, 0xbd, 0xb7, 0x31, 0xe5, 0xbd, 0x2b, 0x00,
	0x76, 0xaf, 0x17, 0x5e, 0xf9, 0x34, 0x9c, 0x9c, 0xa0, 0x7b, 0xf3, 0x13, 0x28, 0x85, 0xc7, 0x47,
	0xe7, 0xa0, 0xd6, 0xf1, 0xfa, 0x7d, 0x87, 0xb5, 0x87, 0xac, 0x91, 0xc3, 0x73, 0x72, 0x3a, 0xda,
	0xb8, 0x04, 0xf3, 0x7e, 0x40, 0x7c, 0x3b, 0x20, 0xf1, 0x4e, 0xe1, 0x79, 0x5c, 0x53, 0xf3, 0xe1,
	0x56, 0xf3, 0x33, 0x03, 0xaa, 0x43, 0xe1, 0x80, 0x76, 0xc7, 0xf5, 0x34, 0xbb, 0xbc, 0x32, 0x75,
	0x78, 0x59, 0xab, 0xfb, 0x7e, 0x40, 0x28, 0x95, 0xf6, 0x4f, 0xea, 0x92, 0x00, 0x48, 0x52, 0x76,
	0xe0, 0x13, 0xe5, 0x86, 0x67, 0xf5, 0x9d, 0xb2, 0xa0, 0xb9, 0x73, 0xe0, 0x13, 0x84, 0xc0, 0xe8,
	0xdb, 0xfb, 0xc2, 0x4b, 0xf9, 0x35, 0x0d, 0xf3, 0x01, 0x77, 0xbe, 0x4c, 0x5e, 0x99, 0x35, 0x1b,
	0xe6, 0x39, 0xf3, 0x0a, 0x40, 0xfc, 0x45, 0x74, 0x0a, 0xf2, 0x01, 0xd9, 0x25, 0xfb, 0x2a, 0xfc,
	0xe4, 0x00, 0x9d, 0x81, 0x82, 0x1f, 0x90, 0x1d, 0x67, 0xbf, 0xae, 0x37, 0x8c, 0x66, 0x19, 0xab,
	0x51, 0xab, 0x14, 0x26, 0x2f, 0xfe, 0xeb, 0xa1, 0xe3, 0x76, 0xbd, 0x87, 0xe6, 0xb7, 0x1a, 0x40,
	0x1c, 0xf3, 0xe8, 0x36, 0x70, 0x53, 0x0d, 0x3a, 0x6c, 0x10, 0x90, 0xae, 0x72, 0x42, 0x26, 0x89,
	0x25, 0xe0, 0xe8, 0xba, 0xa8, 0x69, 0x8e, 0xbb, 0x3b, 0x8d, 0xd8, 0x15, 0xb4, 0x55, 0x86, 0x62,
	0xc7, 0x73, 0x19, 0x71, 0xd9, 0xe2, 0x05, 0xa8, 0x0e, 0x15, 0x10, 0x54, 0x81, 0xd2, 0x0d, 0x2f,
	0x78, 0x68, 0x07, 0x5d, 0x3a, 0x3f, 0x83, 0xaa, 0x50, 0x6e, 0xd9, 0x9d, 0x07, 0x72, 0xa8, 0xb5,
	0x6a, 0x61, 0x75, 0x57, 0x52, 0x6f, 0xcd, 0x41, 0x45, 0xd8, 0x30, 0x1c, 0xd7, 0xa0, 0x2a, 0xcd,
	0x11, 0xc6, 0x42, 0x11, 0xf2, 0xe2, 0xeb, 0x8b, 0xbf, 0x15, 0xa0, 0x24, 0xcf, 0x43, 0x7d, 0xb4,
	0x02, 0x79, 0x71, 0x6c, 0x65, 0x0d, 0xeb, 0xe8, 0x4b, 0x50, 0x5f, 0xfc, 0x58, 0xe5, 0xfb, 0xb0,
	0x04, 0x9b, 0x7f, 0xe5, 0xa1, 0x1c, 0x4d, 0x22, 0x3c, 0xcc, 0xf9, 0x5e, 0x36, 0x4e, 0x0b, 0x93,
	0x8e, 0x17, 0x74, 0xc9, 0xd0, 0x17, 0xd0, 0x26, 0xe4, 0x78, 0xd9, 0x54, 0xb6, 0x3e, 0x1e, 0xa5,
	0x60, 0x42, 0x4b, 0xe3, 0x81, 0x6f, 0xa8, 0x44, 0x3e, 0x1a, 0xfa, 0x1b, 0x30, 0xeb, 0x7a, 0xf1,
	0x36, 0xa9, 0xef, 0xd7, 0x52, 0x9d, 0x21, 0x52, 0x8e, 0xeb, 0x45, 0xe9, 0xe1, 0x47, 0x83, 0xbb,
	0x3a, 0x71, 0x22, 0x74, 0x09, 0x74, 0x27, 0x14, 0x64, 0xe3, 0x30, 0x5e, 0x2e, 0x66, 0xac, 0x3b,
	0xdd, 0xd1, 0x02, 0xa5, 0x8f, 0x15, 0xa8, 0x73, 0x50, 0x53, 0x1b, 0xa2, 0x3a, 0x65, 0xc8, 0xbc,
	0x26, 0xa7, 0x71, 0x58, 0xab, 0x26, 0xe5, 0xb5, 0xdc, 0xc4, 0xbc, 0x36, 0x29, 0x57, 0xe6, 0x27,
	0xe6, 0xca, 0x1d, 0x28, 0xf5, 0x09, 0xb3, 0xbb, 0x36, 0xb3, 0xeb, 0x85, 0x86, 0xd1, 0x9c, 0x5d,
	0x5e, 0x3f, 0x8e, 0xc7, 0xac, 0x0d, 0x45, 0xb6, 0xea, 0xb2, 0xe0, 0x00, 0x47, 0xdc, 0xe2, 0x40,
	0x03, 0xca, 0xbc, 0x7e, 0x3b, 0xfa, 0x1c, 0xef, 0x5c, 0x2a, 0x78, 0x4e, 0x4e, 0x87, 0x38, 0x84,
	0x20, 0x27, 0x56, 0x4b, 0x62, 0x55, 0xfc, 0x36, 0xdf, 0x85, 0xea, 0x10, 0x2f, 0x9a, 0x07, 0xe3,
	0x01, 0x39, 0x50, 0xd9, 0x86, 0xff, 0xe4, 0x19, 0x68, 0xcf, 0xee, 0x0d, 0x42, 0xfb, 0xca, 0xc1,
	0x15, 0xfd, 0x6d, 0xad, 0x05, 0x71, 0xf5, 0x8c, 0x23, 0xeb, 0x87, 0x02, 0x94, 0xaf, 0xf9, 0x3e,
	0x71, 0x45, 0x1f, 0x7d, 0x6b, 0xb4, 0x8f, 0x7e, 0xfd, 0x30, 0x1b, 0x44, 0x38, 0x2b, 0x6e, 0x4d,
	0x43, 0x3c, 0xda, 0xe6, 0x3e, 0xf2, 0x7c, 0x8f, 0x92, 0x6e, 0xbb, 0x4f, 0x28, 0xb5, 0x77, 0xc3,
	0xdc, 0xfe, 0x66, 0x3a, 0xce, 0x4d, 0x85, 0xde, 0x90, 0xe0, 0xb5, 0x19, 0xee, 0xdc, 0xa1, 0x29,
	0xf3, 0x27, 0x3d, 0xee, 0xd7, 0x8f, 0xd9, 0xfe, 0xac, 0x8b, 0x96, 0x4f, 0x75, 0xfc, 0xc6, 0xd1,
	0x6f, 0x88, 0xf8, 0x9c, 0x61, 0xb8, 0x94, 0x5c, 0x4f, 0x36, 0x64, 0xe8, 0x2a, 0x18, 0xb6, 0x7b,
	0xa0, 0x62, 0x2e, 0x23, 0x0b, 0x47, 0x22, 0x1c, 0x65, 0x4a, 0xb2, 0xef, 0x50, 0x46, 0x85, 0x64,
	0x33, 0x53, 0x55, 0xe4, 0xd2, 0xaa, 0xa0, 0x68, 0x99, 0x50, 0x27, 0xfb, 0x3e, 0xe9, 0x30, 0xd2,
	0x6d, 0x8f, 0x44, 0x99, 0xf9, 0x95, 0x0e, 0xb5, 0x11, 0x73, 0x4f, 0x11, 0xdf, 0xed, 0x44, 0x04,
	0xe9, 0x22, 0x82, 0xae, 0x4f, 0xe5, 0xe9, 0x2c, 0xa1, 0x63, 0x1c, 0x1a, 0x3a, 0xb9, 0x67, 0x14,
	0x3a, 0x51, 0xb8, 0x24, 0x8b, 0xdf, 0x77, 0x06, 0x40, 0x78, 0x07, 0xea, 0xa3, 0xf3, 0x30, 0xdf,
	0x19, 0x04, 0x01, 0xbf, 0x6e, 0x24, 0x33, 0x4d, 0xc9, 0xac, 0xa6, 0x56, 0xa2, 0x04, 0x76, 0x3b,
	0xa9, 0x36, 0x19, 0x15, 0x17, 0xd2, 0xd8, 0x2a, 0x91, 0x9d, 0x63, 0xb9, 0x6d, 0x24, 0xba, 0x62,
	0xa9, 0xdc, 0x8b, 0x29, 0xb9, 0xa2, 0x86, 0x58, 0x4b, 0x34, 0xc4, 0xbc, 0xbc, 0xf2, 0x6f, 0x28,
	0xfd, 0x66, 0x3b, 0x97, 0x86, 0x25, 0xf8, 0x1f, 0xef, 0x57, 0x23, 0x8f, 0x3c, 0x0f, 0xcf, 0x8d,
	0xda, 0x3d, 0xec, 0x27, 0x4e, 0x40, 0x2d, 0xa4, 0x51, 0x53, 0x8b, 0x5f, 0x1b, 0x50, 0x5e, 0x21,
	0x3d, 0xc2, 0x08, 0x4f, 0x77, 0x37, 0x33, 0xa5, 0xbb, 0x08, 0x37, 0xfe, 0x87, 0x83, 0xff, 0x30,
	0x11, 0xc5, 0xa7, 0x3a, 0x4e, 0x22, 0x1a, 0x67, 0x99, 0x3a, 0x11, 0x8d, 0x53, 0xa5, 0x4f, 0x44,
	0x51, 0x59, 0xfa, 0x52, 0x07, 0x08, 0x89, 0xa8, 0x3f, 0x24, 0x71, 0xed, 0x68, 0x89, 0xc7, 0xc8,
	0xc9, 0x6f, 0xbe, 0x48, 0xe2, 0x29, 0x42, 0x2f, 0xc1, 0x15, 0x3d, 0xfb, 0xfe, 0x65, 0x89, 0x4f,
	0xd0, 0xf1, 0xf7, 0x06, 0x54, 0xee, 0x78, 0xfd, 0x6d, 0xca, 0x3c, 0x57, 0x48, 0x79, 0x7d, 0x54,
	0xca, 0x97, 0x0e, 0xbb, 0x54, 0x12, 0x3a, 0xae, 0xe6, 0x5f, 0x9e, 0x9d, 0x9a, 0x37, 0xc6, 0xd5,
	0x6c, 0xa5, 0x3e, 0xd8, 0xb8, 0xa0, 0x5b, 0x49, 0x41, 0x67, 0x27, 0x12, 0x9a, 0xbe, 0x3b, 0x59,
	0xd3, 0xd9, 0xd9, 0xa6, 0x90, 0xf5, 0x37, 0x3a, 0x54, 0x13, 0x5c, 0xd4, 0x47, 0x9b, 0x63, 0xca,
	0x5e, 0x4e, 0x79, 0x90, 0xa7, 0x89, 0xfb, 0xe6, 0xb0, 0xb8, 0x2f, 0xa6, 0xa7, 0xfb, 0x1f, 0xe9,
	0xfb, 0x89, 0x06, 0x39, 0xde, 0x58, 0xa0, 0x8d, 0x09, 0xef, 0xdf, 0xf3, 0x47, 0xb5, 0x23, 0xd6,
	0x56, 0x04, 0x19, 0x79, 0x01, 0xd7, 0x87, 0x5e, 0xc0, 0xe5, 0xf8, 0x59, 0x6b, 0xee, 0x01, 0xc4,
	0x28, 0xb4, 0x0c, 0xa7, 0xfb, 0x1e, 0x65, 0x6d, 0xea, 0xec, 0xba, 0xce, 0x8e, 0xd3, 0xb1, 0x5d,
	0xd6, 0xde, 0x76, 0x98, 0x0c, 0x2e, 0x03, 0x9f, 0xe4, 0x8b, 0x5b, 0xf1, 0x5a, 0xcb, 0x61, 0x14,
	0x5d, 0x86, 0x33, 0x3d, 0x62, 0x4f, 0x02, 0xe9, 0x02, 0x74, 0x4a, 0xac, 0x8e, 0xa0, 0x5a, 0x45,
	0xd5, 0x74, 0x2c, 0xff, 0xa9, 0x43, 0x51, 0xca, 0x9c, 0xa2, 0x2d, 0xc8, 0xf1, 0x77, 0x05, 0x3a,
	0x9b, 0xe2, 0x81, 0x6e, 0xbe, 0x9c, 0xe6, 0x9d, 0x72, 0x49, 0x43, 0x1f, 0x43, 0x41, 0xd6, 0x6b,
	0xf4, 0x4a, 0xaa, 0xbe, 0xcc, 0x7c, 0x35, 0x5d, 0xe9, 0x6f, 0x6a, 0xe8, 0x1e, 0x14, 0x64, 0x9e,
	0x3c, 0x9c, 0x3a, 0x2a, 0x0d, 0x87, 0x53, 0x27, 0x12, 0xff, 0x7d, 0x28, 0x47, 0x1a, 0x45, 0xcd,
	0xb4, 0x21, 0x6a, 0x2e, 0xa5, 0x16, 0x7d, 0xeb, 0xe2, 0xcf, 0x8f, 0x16, 0xb4, 0x5f, 0x1f, 0x2d,
	0x68, 0xbf, 0x3f, 0x5a, 0xd0, 0xbe, 0x78, 0xbc, 0x30, 0x03, 0x2f, 0x76, 0xbc, 0xbe, 0xc4, 0x4f,
	0x82, 0x6f, 0x17, 0xc4, 0xbf, 0x26, 0xde, 0xf8, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xa1, 0xa9, 0xb9,
	0x71, 0xab, 0x18, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamsClient is the client API for Streams service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamsClient interface {
	Read(ctx context.Context, in *ReadReq, opts ...grpc.CallOption) (Streams_ReadClient, error)
	Append(ctx context.Context, opts ...grpc.CallOption) (Streams_AppendClient, error)
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error)
	Tombstone(ctx context.Context, in *TombstoneReq, opts ...grpc.CallOption) (*TombstoneResp, error)
}

type streamsClient struct {
	cc *grpc.ClientConn
}

func NewStreamsClient(cc *grpc.ClientConn) StreamsClient {
	return &streamsClient{cc}
}

func (c *streamsClient) Read(ctx context.Context, in *ReadReq, opts ...grpc.CallOption) (Streams_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streams_serviceDesc.Streams[0], "/event_store.client.streams.Streams/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_ReadClient interface {
	Recv() (*ReadResp, error)
	grpc.ClientStream
}

type streamsReadClient struct {
	grpc.ClientStream
}

func (x *streamsReadClient) Recv() (*ReadResp, error) {
	m := new(ReadResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamsClient) Append(ctx context.Context, opts ...grpc.CallOption) (Streams_AppendClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Streams_serviceDesc.Streams[1], "/event_store.client.streams.Streams/Append", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsAppendClient{stream}
	return x, nil
}

type Streams_AppendClient interface {
	Send(*AppendReq) error
	CloseAndRecv() (*AppendResp, error)
	grpc.ClientStream
}

type streamsAppendClient struct {
	grpc.ClientStream
}

func (x *streamsAppendClient) Send(m *AppendReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamsAppendClient) CloseAndRecv() (*AppendResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AppendResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamsClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error) {
	out := new(DeleteResp)
	err := c.cc.Invoke(ctx, "/event_store.client.streams.Streams/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamsClient) Tombstone(ctx context.Context, in *TombstoneReq, opts ...grpc.CallOption) (*TombstoneResp, error) {
	out := new(TombstoneResp)
	err := c.cc.Invoke(ctx, "/event_store.client.streams.Streams/Tombstone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamsServer is the server API for Streams service.
type StreamsServer interface {
	Read(*ReadReq, Streams_ReadServer) error
	Append(Streams_AppendServer) error
	Delete(context.Context, *DeleteReq) (*DeleteResp, error)
	Tombstone(context.Context, *TombstoneReq) (*TombstoneResp, error)
}

// UnimplementedStreamsServer can be embedded to have forward compatible implementations.
type UnimplementedStreamsServer struct {
}

func (*UnimplementedStreamsServer) Read(req *ReadReq, srv Streams_ReadServer) error {
	return status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedStreamsServer) Append(srv Streams_AppendServer) error {
	return status.Errorf(codes.Unimplemented, "method Append not implemented")
}
func (*UnimplementedStreamsServer) Delete(ctx context.Context, req *DeleteReq) (*DeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedStreamsServer) Tombstone(ctx context.Context, req *TombstoneReq) (*TombstoneResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tombstone not implemented")
}

func RegisterStreamsServer(s *grpc.Server, srv StreamsServer) {
	s.RegisterService(&_Streams_serviceDesc, srv)
}

func _Streams_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).Read(m, &streamsReadServer{stream})
}

type Streams_ReadServer interface {
	Send(*ReadResp) error
	grpc.ServerStream
}

type streamsReadServer struct {
	grpc.ServerStream
}

func (x *streamsReadServer) Send(m *ReadResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Streams_Append_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamsServer).Append(&streamsAppendServer{stream})
}

type Streams_AppendServer interface {
	SendAndClose(*AppendResp) error
	Recv() (*AppendReq, error)
	grpc.ServerStream
}

type streamsAppendServer struct {
	grpc.ServerStream
}

func (x *streamsAppendServer) SendAndClose(m *AppendResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamsAppendServer) Recv() (*AppendReq, error) {
	m := new(AppendReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Streams_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/event_store.client.streams.Streams/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Streams_Tombstone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TombstoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamsServer).Tombstone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/event_store.client.streams.Streams/Tombstone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamsServer).Tombstone(ctx, req.(*TombstoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Streams_serviceDesc = grpc.ServiceDesc{
	ServiceName: "event_store.client.streams.Streams",
	HandlerType: (*StreamsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Streams_Delete_Handler,
		},
		{
			MethodName: "Tombstone",
			Handler:    _Streams_Tombstone_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _Streams_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Append",
			Handler:       _Streams_Append_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "streams.proto",
}

func (m *ReadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UuidOption != nil {
		{
			size, err := m.UuidOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.FilterOption != nil {
		{
			size := m.FilterOption.Size()
			i -= size
			if _, err := m.FilterOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CountOption != nil {
		{
			size := m.CountOption.Size()
			i -= size
			if _, err := m.CountOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResolveLinks {
		i--
		if m.ResolveLinks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReadDirection != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.ReadDirection))
		i--
		dAtA[i] = 0x18
	}
	if m.StreamOption != nil {
		{
			size := m.StreamOption.Size()
			i -= size
			if _, err := m.StreamOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Stream != nil {
		{
			size, err := m.Stream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_All) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_All) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.All != nil {
		{
			size, err := m.All.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_Count) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_Count) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Count))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_Subscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_Subscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subscription != nil {
		{
			size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_NoFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_NoFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoFilter != nil {
		{
			size, err := m.NoFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_StreamOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_StreamOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_StreamOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RevisionOption != nil {
		{
			size := m.RevisionOption.Size()
			i -= size
			if _, err := m.RevisionOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.StreamName) > 0 {
		i -= len(m.StreamName)
		copy(dAtA[i:], m.StreamName)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.StreamName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_StreamOptions_Revision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_StreamOptions_Revision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Revision))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_StreamOptions_Start) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_StreamOptions_Start) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_StreamOptions_End) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_StreamOptions_End) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_AllOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_AllOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_AllOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllOption != nil {
		{
			size := m.AllOption.Size()
			i -= size
			if _, err := m.AllOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_AllOptions_Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_AllOptions_Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_AllOptions_Start) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_AllOptions_Start) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_AllOptions_End) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_AllOptions_End) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_SubscriptionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_SubscriptionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_SubscriptionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreparePosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.PreparePosition))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitPosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_FilterOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_FilterOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Window != nil {
		{
			size := m.Window.Size()
			i -= size
			if _, err := m.Window.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Filter != nil {
		{
			size := m.Filter.Size()
			i -= size
			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_FilterOptions_StreamName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions_StreamName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamName != nil {
		{
			size, err := m.StreamName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_FilterOptions_EventType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions_EventType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EventType != nil {
		{
			size, err := m.EventType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_FilterOptions_Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions_Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Max))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_FilterOptions_Count) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions_Count) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Count != nil {
		{
			size, err := m.Count.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_FilterOptions_Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_FilterOptions_Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_FilterOptions_Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Prefix) > 0 {
		for iNdEx := len(m.Prefix) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefix[iNdEx])
			copy(dAtA[i:], m.Prefix[iNdEx])
			i = encodeVarintStreams(dAtA, i, uint64(len(m.Prefix[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Regex) > 0 {
		i -= len(m.Regex)
		copy(dAtA[i:], m.Regex)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.Regex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_UUIDOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Options_UUIDOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_UUIDOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadReq_Options_UUIDOption_Structured) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_UUIDOption_Structured) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Structured != nil {
		{
			size, err := m.Structured.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Options_UUIDOption_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Options_UUIDOption_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.String_ != nil {
		{
			size, err := m.String_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadReq_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReq_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadReq_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadResp_ReadEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResp_ReadEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp_ReadEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size := m.Position.Size()
			i -= size
			if _, err := m.Position.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadResp_ReadEvent_CommitPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp_ReadEvent_CommitPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ReadResp_ReadEvent_NoPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp_ReadEvent_NoPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPosition != nil {
		{
			size, err := m.NoPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReadResp_ReadEvent_RecordedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResp_ReadEvent_RecordedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp_ReadEvent_RecordedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CustomMetadata) > 0 {
		i -= len(m.CustomMetadata)
		copy(dAtA[i:], m.CustomMetadata)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.CustomMetadata)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStreams(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStreams(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStreams(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.CommitPosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
		i--
		dAtA[i] = 0x28
	}
	if m.PreparePosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.PreparePosition))
		i--
		dAtA[i] = 0x20
	}
	if m.StreamRevision != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.StreamRevision))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StreamName) > 0 {
		i -= len(m.StreamName)
		copy(dAtA[i:], m.StreamName)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.StreamName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadResp_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResp_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResp_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AppendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppendReq_Options_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AppendReq_ProposedMessage_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_ProposedMessage_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposedMessage != nil {
		{
			size, err := m.ProposedMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AppendReq_Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReq_Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpectedStreamRevision != nil {
		{
			size := m.ExpectedStreamRevision.Size()
			i -= size
			if _, err := m.ExpectedStreamRevision.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.StreamName) > 0 {
		i -= len(m.StreamName)
		copy(dAtA[i:], m.StreamName)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.StreamName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendReq_Options_Revision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options_Revision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Revision))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *AppendReq_Options_NoStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options_NoStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStream != nil {
		{
			size, err := m.NoStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AppendReq_Options_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AppendReq_Options_StreamExists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Options_StreamExists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamExists != nil {
		{
			size, err := m.StreamExists.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AppendReq_ProposedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReq_ProposedMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_ProposedMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CustomMetadata) > 0 {
		i -= len(m.CustomMetadata)
		copy(dAtA[i:], m.CustomMetadata)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.CustomMetadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStreams(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStreams(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStreams(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendReq_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReq_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReq_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AppendResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PositionOption != nil {
		{
			size := m.PositionOption.Size()
			i -= size
			if _, err := m.PositionOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CurrentRevisionOption != nil {
		{
			size := m.CurrentRevisionOption.Size()
			i -= size
			if _, err := m.CurrentRevisionOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppendResp_CurrentRevision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_CurrentRevision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.CurrentRevision))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *AppendResp_NoStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_NoStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStream != nil {
		{
			size, err := m.NoStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AppendResp_Position_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_Position_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AppendResp_Empty_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_Empty_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Empty != nil {
		{
			size, err := m.Empty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AppendResp_Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendResp_Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreparePosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.PreparePosition))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitPosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendResp_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendResp_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendResp_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteReq_Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReq_Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpectedStreamRevision != nil {
		{
			size := m.ExpectedStreamRevision.Size()
			i -= size
			if _, err := m.ExpectedStreamRevision.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.StreamName) > 0 {
		i -= len(m.StreamName)
		copy(dAtA[i:], m.StreamName)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.StreamName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteReq_Options_Revision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Options_Revision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Revision))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *DeleteReq_Options_NoStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Options_NoStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStream != nil {
		{
			size, err := m.NoStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DeleteReq_Options_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Options_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DeleteReq_Options_StreamExists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Options_StreamExists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamExists != nil {
		{
			size, err := m.StreamExists.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DeleteReq_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReq_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReq_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PositionOption != nil {
		{
			size := m.PositionOption.Size()
			i -= size
			if _, err := m.PositionOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResp_Position_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp_Position_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DeleteResp_Empty_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp_Empty_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Empty != nil {
		{
			size, err := m.Empty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DeleteResp_Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResp_Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp_Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreparePosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.PreparePosition))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitPosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResp_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResp_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResp_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneReq_Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneReq_Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpectedStreamRevision != nil {
		{
			size := m.ExpectedStreamRevision.Size()
			i -= size
			if _, err := m.ExpectedStreamRevision.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.StreamName) > 0 {
		i -= len(m.StreamName)
		copy(dAtA[i:], m.StreamName)
		i = encodeVarintStreams(dAtA, i, uint64(len(m.StreamName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneReq_Options_Revision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Options_Revision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintStreams(dAtA, i, uint64(m.Revision))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *TombstoneReq_Options_NoStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Options_NoStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoStream != nil {
		{
			size, err := m.NoStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TombstoneReq_Options_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Options_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TombstoneReq_Options_StreamExists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Options_StreamExists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamExists != nil {
		{
			size, err := m.StreamExists.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TombstoneReq_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneReq_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneReq_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PositionOption != nil {
		{
			size := m.PositionOption.Size()
			i -= size
			if _, err := m.PositionOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneResp_Position_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneResp_Position_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TombstoneResp_Empty_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneResp_Empty_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Empty != nil {
		{
			size, err := m.Empty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TombstoneResp_Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneResp_Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneResp_Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreparePosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.PreparePosition))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitPosition != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.CommitPosition))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TombstoneResp_Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TombstoneResp_Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TombstoneResp_Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UUID_Structured_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID_Structured_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Structured != nil {
		{
			size, err := m.Structured.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStreams(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UUID_String_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID_String_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.String_)
	copy(dAtA[i:], m.String_)
	i = encodeVarintStreams(dAtA, i, uint64(len(m.String_)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *UUID_Structured) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID_Structured) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID_Structured) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeastSignificantBits != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.LeastSignificantBits))
		i--
		dAtA[i] = 0x10
	}
	if m.MostSignificantBits != 0 {
		i = encodeVarintStreams(dAtA, i, uint64(m.MostSignificantBits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStreams(dAtA []byte, offset int, v uint64) int {
	offset -= sovStreams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamOption != nil {
		n += m.StreamOption.Size()
	}
	if m.ReadDirection != 0 {
		n += 1 + sovStreams(uint64(m.ReadDirection))
	}
	if m.ResolveLinks {
		n += 2
	}
	if m.CountOption != nil {
		n += m.CountOption.Size()
	}
	if m.FilterOption != nil {
		n += m.FilterOption.Size()
	}
	if m.UuidOption != nil {
		l = m.UuidOption.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stream != nil {
		l = m.Stream.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_All) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Count))
	return n
}
func (m *ReadReq_Options_Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_NoFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoFilter != nil {
		l = m.NoFilter.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_StreamOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamName)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.RevisionOption != nil {
		n += m.RevisionOption.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_StreamOptions_Revision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Revision))
	return n
}
func (m *ReadReq_Options_StreamOptions_Start) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_StreamOptions_End) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_AllOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllOption != nil {
		n += m.AllOption.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_AllOptions_Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_AllOptions_Start) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_AllOptions_End) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_SubscriptionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitPosition != 0 {
		n += 1 + sovStreams(uint64(m.CommitPosition))
	}
	if m.PreparePosition != 0 {
		n += 1 + sovStreams(uint64(m.PreparePosition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_FilterOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	if m.Window != nil {
		n += m.Window.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_FilterOptions_StreamName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamName != nil {
		l = m.StreamName.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_FilterOptions_EventType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != nil {
		l = m.EventType.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_FilterOptions_Max) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Max))
	return n
}
func (m *ReadReq_Options_FilterOptions_Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		l = m.Count.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_FilterOptions_Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if len(m.Prefix) > 0 {
		for _, s := range m.Prefix {
			l = len(s)
			n += 1 + l + sovStreams(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_UUIDOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadReq_Options_UUIDOption_Structured) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Structured != nil {
		l = m.Structured.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Options_UUIDOption_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.String_ != nil {
		l = m.String_.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadReq_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadResp_ReadEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.Position != nil {
		n += m.Position.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadResp_ReadEvent_CommitPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.CommitPosition))
	return n
}
func (m *ReadResp_ReadEvent_NoPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPosition != nil {
		l = m.NoPosition.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *ReadResp_ReadEvent_RecordedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	l = len(m.StreamName)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.StreamRevision != 0 {
		n += 1 + sovStreams(uint64(m.StreamRevision))
	}
	if m.PreparePosition != 0 {
		n += 1 + sovStreams(uint64(m.PreparePosition))
	}
	if m.CommitPosition != 0 {
		n += 1 + sovStreams(uint64(m.CommitPosition))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStreams(uint64(len(k))) + 1 + len(v) + sovStreams(uint64(len(v)))
			n += mapEntrySize + 1 + sovStreams(uint64(mapEntrySize))
		}
	}
	l = len(m.CustomMetadata)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadResp_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendReq_Options_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendReq_ProposedMessage_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposedMessage != nil {
		l = m.ProposedMessage.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendReq_Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamName)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.ExpectedStreamRevision != nil {
		n += m.ExpectedStreamRevision.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendReq_Options_Revision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Revision))
	return n
}
func (m *AppendReq_Options_NoStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStream != nil {
		l = m.NoStream.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendReq_Options_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendReq_Options_StreamExists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamExists != nil {
		l = m.StreamExists.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendReq_ProposedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStreams(uint64(len(k))) + 1 + len(v) + sovStreams(uint64(len(v)))
			n += mapEntrySize + 1 + sovStreams(uint64(mapEntrySize))
		}
	}
	l = len(m.CustomMetadata)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendReq_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentRevisionOption != nil {
		n += m.CurrentRevisionOption.Size()
	}
	if m.PositionOption != nil {
		n += m.PositionOption.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendResp_CurrentRevision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.CurrentRevision))
	return n
}
func (m *AppendResp_NoStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStream != nil {
		l = m.NoStream.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendResp_Position_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendResp_Empty_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *AppendResp_Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitPosition != 0 {
		n += 1 + sovStreams(uint64(m.CommitPosition))
	}
	if m.PreparePosition != 0 {
		n += 1 + sovStreams(uint64(m.PreparePosition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendResp_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteReq_Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamName)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.ExpectedStreamRevision != nil {
		n += m.ExpectedStreamRevision.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteReq_Options_Revision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Revision))
	return n
}
func (m *DeleteReq_Options_NoStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStream != nil {
		l = m.NoStream.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *DeleteReq_Options_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *DeleteReq_Options_StreamExists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamExists != nil {
		l = m.StreamExists.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *DeleteReq_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOption != nil {
		n += m.PositionOption.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteResp_Position_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *DeleteResp_Empty_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *DeleteResp_Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitPosition != 0 {
		n += 1 + sovStreams(uint64(m.CommitPosition))
	}
	if m.PreparePosition != 0 {
		n += 1 + sovStreams(uint64(m.PreparePosition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteResp_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneReq_Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamName)
	if l > 0 {
		n += 1 + l + sovStreams(uint64(l))
	}
	if m.ExpectedStreamRevision != nil {
		n += m.ExpectedStreamRevision.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneReq_Options_Revision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovStreams(uint64(m.Revision))
	return n
}
func (m *TombstoneReq_Options_NoStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoStream != nil {
		l = m.NoStream.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *TombstoneReq_Options_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *TombstoneReq_Options_StreamExists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamExists != nil {
		l = m.StreamExists.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *TombstoneReq_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionOption != nil {
		n += m.PositionOption.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneResp_Position_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *TombstoneResp_Empty_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *TombstoneResp_Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitPosition != 0 {
		n += 1 + sovStreams(uint64(m.CommitPosition))
	}
	if m.PreparePosition != 0 {
		n += 1 + sovStreams(uint64(m.PreparePosition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TombstoneResp_Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UUID_Structured_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Structured != nil {
		l = m.Structured.Size()
		n += 1 + l + sovStreams(uint64(l))
	}
	return n
}
func (m *UUID_String_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovStreams(uint64(l))
	return n
}
func (m *UUID_Structured) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MostSignificantBits != 0 {
		n += 1 + sovStreams(uint64(m.MostSignificantBits))
	}
	if m.LeastSignificantBits != 0 {
		n += 1 + sovStreams(uint64(m.LeastSignificantBits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStreams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStreams(x uint64) (n int) {
	return sovStreams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ReadReq_Options{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_StreamOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamOption = &ReadReq_Options_Stream{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_AllOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StreamOption = &ReadReq_Options_All{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadDirection", wireType)
			}
			m.ReadDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadDirection |= ReadReq_Options_ReadDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveLinks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResolveLinks = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CountOption = &ReadReq_Options_Count{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_SubscriptionOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CountOption = &ReadReq_Options_Subscription{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_FilterOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterOption = &ReadReq_Options_Filter{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterOption = &ReadReq_Options_NoFilter{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UuidOption == nil {
				m.UuidOption = &ReadReq_Options_UUIDOption{}
			}
			if err := m.UuidOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_StreamOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RevisionOption = &ReadReq_Options_StreamOptions_Revision{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RevisionOption = &ReadReq_Options_StreamOptions_Start{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RevisionOption = &ReadReq_Options_StreamOptions_End{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_AllOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_Position{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllOption = &ReadReq_Options_AllOptions_Position{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllOption = &ReadReq_Options_AllOptions_Start{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllOption = &ReadReq_Options_AllOptions_End{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_SubscriptionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			m.CommitPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePosition", wireType)
			}
			m.PreparePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_FilterOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_FilterOptions_Expression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &ReadReq_Options_FilterOptions_StreamName{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Options_FilterOptions_Expression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &ReadReq_Options_FilterOptions_EventType{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Window = &ReadReq_Options_FilterOptions_Max{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Window = &ReadReq_Options_FilterOptions_Count{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_FilterOptions_Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Options_UUIDOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Structured", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ReadReq_Options_UUIDOption_Structured{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ReadReq_Options_UUIDOption_String_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReq_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &ReadResp_ReadEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResp_ReadEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &ReadResp_ReadEvent_RecordedEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &ReadResp_ReadEvent_RecordedEvent{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Position = &ReadResp_ReadEvent_CommitPosition{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReadResp_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Position = &ReadResp_ReadEvent_NoPosition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResp_ReadEvent_RecordedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &UUID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRevision", wireType)
			}
			m.StreamRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRevision |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePosition", wireType)
			}
			m.PreparePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			m.CommitPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStreams
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStreams
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStreams
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStreams
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStreams
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStreams
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStreams
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStreams(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStreams
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMetadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomMetadata = append(m.CustomMetadata[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomMetadata == nil {
				m.CustomMetadata = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResp_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReq_Options{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &AppendReq_Options_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReq_ProposedMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &AppendReq_ProposedMessage_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReq_Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectedStreamRevision = &AppendReq_Options_Revision{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &AppendReq_Options_NoStream{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &AppendReq_Options_Any{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamExists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &AppendReq_Options_StreamExists{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReq_ProposedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &UUID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStreams
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStreams
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStreams
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStreams
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStreams
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStreams
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStreams
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStreams(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStreams
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMetadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomMetadata = append(m.CustomMetadata[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomMetadata == nil {
				m.CustomMetadata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReq_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRevision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurrentRevisionOption = &AppendResp_CurrentRevision{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendResp_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CurrentRevisionOption = &AppendResp_NoStream{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendResp_Position{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &AppendResp_Position_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendResp_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &AppendResp_Empty_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendResp_Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			m.CommitPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePosition", wireType)
			}
			m.PreparePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendResp_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &DeleteReq_Options{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReq_Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectedStreamRevision = &DeleteReq_Options_Revision{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &DeleteReq_Options_NoStream{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &DeleteReq_Options_Any{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamExists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &DeleteReq_Options_StreamExists{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReq_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteResp_Position{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &DeleteResp_Position_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteResp_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &DeleteResp_Empty_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResp_Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			m.CommitPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePosition", wireType)
			}
			m.PreparePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResp_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TombstoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TombstoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &TombstoneReq_Options{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneReq_Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectedStreamRevision = &TombstoneReq_Options_Revision{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TombstoneReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &TombstoneReq_Options_NoStream{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TombstoneReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &TombstoneReq_Options_Any{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamExists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TombstoneReq_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ExpectedStreamRevision = &TombstoneReq_Options_StreamExists{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneReq_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TombstoneResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TombstoneResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TombstoneResp_Position{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &TombstoneResp_Position_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TombstoneResp_Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PositionOption = &TombstoneResp_Empty_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneResp_Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitPosition", wireType)
			}
			m.CommitPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitPosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePosition", wireType)
			}
			m.PreparePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePosition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TombstoneResp_Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Structured", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UUID_Structured{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &UUID_Structured_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStreams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStreams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &UUID_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID_Structured) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Structured: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Structured: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostSignificantBits", wireType)
			}
			m.MostSignificantBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MostSignificantBits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeastSignificantBits", wireType)
			}
			m.LeastSignificantBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeastSignificantBits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStreams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStreams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStreams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStreams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStreams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStreams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStreams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStreams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStreams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStreams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStreams = fmt.Errorf("proto: unexpected end of group")
)
